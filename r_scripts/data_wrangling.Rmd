---
title: "Characterisation of drug-resistant Mycobacterium tuberculosis mutations and transmission in Pakistan"
output: 
  bookdown::html_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
library(knitr)
library(dplyr)
library(tidyr)
library(janitor)
library(qgraph)
library(ape)
library(phytools)
library(coda)
library(ggplot2)
library(ggtree)
library(treeio)
library(scales)
library(gplots)
library(RColorBrewer)
library(randomcoloR)
library(usedist)
library(phytools)
library(sp)
library(english)
knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r functions, echo = F}

# FUNCTIONS ----

heaD <- function(x,...){
  head(x, ...)
}

fmt <- function(x, ...){format(x, big.mark=",",scientific=FALSE, ...)}

len_str <- function(string){
  length(unlist(strsplit(string, split = "")))
}

hs <- function(x, ...){
  print(head(x, ...))
  print("---")
  str(x, ...)
}

to_table <- function(x, pc_dir = "row"){
  # pc_dir = the direction to use for calculating percentages. One of "row", "col", or "all".
  x <- x %>% adorn_totals(c("row", "col")) %>%
    adorn_percentages(c(pc_dir)) %>%
    adorn_pct_formatting(digits = 2)
  formatted_ns <- attr(x, "core") %>% # extract the tabyl's underlying Ns
    adorn_totals(c("row", "col")) %>% # to match the data.frame we're appending to
    dplyr::mutate_if(is.numeric, format, big.mark = ",")
  x %>% adorn_ns(position = "front", ns = formatted_ns)
}

log10_ceiling <- function(x) {
  10^(ceiling(log10(x)))
}

tab2df <- function(tab){
  df <- data.frame(x = matrix(tab, ncol = length(tab)))
  names(df) <- names(tab)
  df
}

print_vect <- function(x){
  gsub(".{1}$", "", paste0(x, sep = ",", collapse = " "))
}

plot.phylo.to.map <- function (x, type = c("phylogram", "direct"), ...) 
{
  type <- type[1]
  if (class(x) == "phylo.to.map") {
    tree <- x$tree
    map <- x$map
    coords <- x$coords
  }
  else stop("x should be an object of class \"phylo.to.map\"")
  if (hasArg(xlim)) 
    xlim <- list(...)$xlim
  else xlim <- map$range[1:2]
  if (hasArg(ylim)) 
    ylim <- list(...)$ylim
  else ylim <- map$range[3:4]
  if (hasArg(fsize)) 
    fsize <- list(...)$fsize
  else fsize <- 1
  if (hasArg(split)) 
    split <- list(...)$split
  else split <- c(0.4, 0.6)
  if (hasArg(psize)) 
    psize <- list(...)$psize
  else psize <- 1
  if (hasArg(cex.points)) {
    cex.points <- list(...)$cex.points
    if (length(cex.points) == 1) 
      cex.points <- c(0.6 * cex.points, cex.points)
  }
  else cex.points <- c(0.6 * psize, psize)
  if (hasArg(mar)) 
    mar <- list(...)$mar
  else mar <- rep(0, 4)
  if (hasArg(asp)) 
    asp <- list(...)$asp
  else asp <- 1
  if (hasArg(ftype)) 
    ftype <- list(...)$ftype
  else ftype <- "reg"
  ftype <- which(c("off", "reg", "b", "i", "bi") == ftype) - 
    1
  if (!ftype) 
    fsize = 0
  if (hasArg(from.tip)) 
    from.tip <- list(...)$from.tip
  else from.tip <- FALSE
  if (hasArg(colors)) 
    colors <- list(...)$colors
  else colors <- "red"
  if (length(colors) == 1) 
    colors <- rep(colors[1], 2)
  if (length(colors) == 2 && type == "phylogram") {
    colors <- matrix(rep(colors, nrow(coords)), nrow(coords), 
                     2, byrow = TRUE)
    rownames(colors) <- rownames(coords)
  }
  if (hasArg(direction)) 
    direction <- list(...)$direction
  else direction <- "downwards"
  if (hasArg(pch)) 
    pch <- list(...)$pch
  else pch <- 21
  if (length(pch) == 1) 
    pch <- rep(pch, 2)
  if (hasArg(lwd)) 
    lwd <- list(...)$lwd
  else lwd <- c(2, 1)
  if (length(lwd) == 1) 
    lwd <- rep(lwd, 2)
  if (hasArg(lty)) 
    lty <- list(...)$lty
  else lty <- "dashed"
  if (hasArg(pts)) 
    pts <- list(...)$pts
  else pts <- TRUE
  if (type == "phylogram") {
    if (direction == "downwards") {
      if (!ftype) 
        ylim <- c(ylim[1], ylim[2] + 0.03 * diff(ylim))
      ylim <- c(ylim[1], ylim[2] + split[1]/split[2] * 
                  (ylim[2] - ylim[1]))
    }
    else if (direction == "rightwards") {
      if (!ftype) 
        xlim <- c(xlim[1] - 0.03 * diff(xlim), xlim[2])
      xlim <- c(xlim[1] - split[1]/split[2] * (xlim[2] - 
                                                 xlim[1]), xlim[2])
    }
  }
  par(mar = mar)
  plot.new()
  plot.window(xlim = xlim, ylim = ylim, asp = asp)
  map(map, add = TRUE, fill = TRUE, col = "black", border="grey", mar = rep(0, 
                                                                            4))
  if (type == "phylogram") {
    cw <- reorder(tree, "cladewise")
    n <- Ntip(cw)
    if (direction == "downwards") {
      dx <- abs(diff(xlim))
      rect(xlim[1] - 1.04 * dx, ylim[2] - split[1] * (ylim[2] - 
                                                        ylim[1]), xlim[2] + 1.04 * dx, ylim[2], col = "white", 
           border = "white")
      pdin <- par()$din[2]
      sh <- (fsize * strwidth(paste(" ", cw$tip.label, 
                                    sep = "")) + 0.3 * fsize * strwidth("W")) * (par()$din[1]/par()$din[2]) * 
        (diff(par()$usr[3:4])/diff(par()$usr[1:2]))
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (ylim[2] - ylim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      x <- vector(length = n + cw$Nnode)
      x[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (xlim[2] - xlim[1]) + xlim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        xx <- x[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        x[nn[i]] <- mean(range(xx))
      }
      Y <- ylim[2] - nodeHeights(cw)
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(x[i], coords[i, 1]), c(Y[which(cw$edge[, 
                                                                    2] == i), 2] - if (from.tip) 0 else sh[i], coords[i, 
                                                                                                                      2]), col = colors[cw$tip.label, ][i, 1], lty = lty, 
                           lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(Y)) lines(rep(x[cw$edge[i, 2]], 
                                     2), Y[i, ], lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(range(x[cw$edge[which(cw$edge[, 
                                                                    1] == i), 2]]), Y[which(cw$edge[, 1] == i), 1], 
                                      lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(x[i], Y[which(cw$edge[, 2] == i), 2], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = c(0, 1), srt = -90, 
               cex = fsize, font = ftype)
        if (pts) 
          points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                     2], col=colors[cw$tip.label, 
                                                                                    2])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = fsize * 
                   strwidth(" ")/(par()$usr[2] - par()$usr[1]) * 
                   (par()$usr[4] - par()$usr[3]), x.lim = par()$usr[1:2], 
                 y.lim = par()$usr[3:4], direction = direction, 
                 tip.color = "black", Ntip = Ntip(cw), Nnode = cw$Nnode, 
                 edge = cw$edge, xx = x, yy = sapply(1:(Ntip(cw) + 
                                                          cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                     y = Y, z = cw$edge))
    }
    else {
      dy <- abs(diff(ylim))
      rect(xlim[1], ylim[1], xlim[1] + split[1] * (xlim[2] - 
                                                     xlim[1]), ylim[2], col = "white", border = "white")
      sh <- fsize * strwidth(paste(" ", cw$tip.label, sep = "")) + 
        0.2 * fsize * strwidth("W")
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (xlim[2] - xlim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      y <- vector(length = n + cw$Nnode)
      y[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (ylim[2] - ylim[1]) + ylim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        yy <- y[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        y[nn[i]] <- mean(range(yy))
      }
      H <- nodeHeights(cw)
      X <- xlim[1] + H
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(X[which(cw$edge[, 2] == i), 
                               2] + if (from.tip) 0 else sh[i], coords[i, 1]), 
                           c(y[i], coords[i, 2]), col = colors[cw$tip.label, 
                                                               ][i, 1], lty = lty, lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(X)) lines(X[i, ], rep(y[cw$edge[i, 
                                                       2]], 2), lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(X[which(cw$edge[, 
                                                      1] == i), 1], range(y[cw$edge[which(cw$edge[, 
                                                                                                  1] == i), 2]]), lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(X[which(cw$edge[, 2] == i), 2], y[i], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = 0.1, cex = fsize, 
               font = ftype)
        if (pts) 
          points(X[which(cw$edge[, 2] == i), 2], y[i], 
                 pch = 21, bg = colors[cw$tip.label, ][i, 
                                                       2], cex = cex.points[1])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = 0.1, 
                 x.lim = par()$usr[1:2], y.lim = par()$usr[3:4], 
                 direction = direction, tip.color = "black", Ntip = Ntip(cw), 
                 Nnode = cw$Nnode, edge = cw$edge, xx = sapply(1:(Ntip(cw) + 
                                                                    cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                               y = X, z = cw$edge), yy = y)
    }
    assign("last_plot.phylo", PP, envir = .PlotPhyloEnv)
  }
  else if (type == "direct") {
    phylomorphospace(tree, coords[, 2:1], add = TRUE, label = "horizontal", 
                     node.size = c(0, psize), lwd = lwd[2], control = list(col.node = setNames(rep(colors[2], 
                                                                                                   max(tree$edge)), 1:max(tree$edge)), col.edge = setNames(rep(colors[1], 
                                                                                                                                                               nrow(tree$edge)), tree$edge[, 2])), ftype = c("off", 
                                                                                                                                                                                                             "reg", "b", "i", "bi")[ftype + 1], fsize = fsize)
  }
}


```

```{r variables, echo = F}


# VARIABLES ----


id_col <- "wgs_id"
rnd <- 2
drugs <- c("rifampicin", "isoniazid", "ethambutol", "pyrazinamide", "streptomycin", 
             "ofloxacin", "moxifloxacin", "levofloxacin", "amikacin", "kanamycin", "capreomycin", "ciprofloxacin", "prothionamide", 
             "ethionamide", "para_aminosalicylic_acid", "cycloserine",
             "clarithromycin", "clofazimine", "bedaquiline", "linezolid", "rifabutin", "delamanid")
fq <- "fluoroquinolones, ofloxacin, levofloxacin, ciprofloxacin, moxifloxacin"
agc <- "capreomycin, streptomycin, amikacin, kanamycin, aminoglycosides"
align <- c("l", "r", "r")
col <- "cornflowerblue"
threshold <- 10
threshold_vect <- c(0, 1, seq(5, 50, 5))
plot_text_sz <- 0.5
main_cex <- 1.5
dr_status_vect <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other")

```

```{r paths, echo = F}


# PATHS ----


methods_path <- "../methods/"
metadata_path <- "../metadata/"
newick_path <- "../newick/"
plots_path <- "../plots/"
db_path <- "../../pipeline/db/"
dist_path <- "../dist_and_pca/"
beast_results_path <- "../beast_results/"

```

```{r files, echo = F}


# FILES ----


# Metadata
metadata_file <- paste0(metadata_path, "pakistan_metadata.csv")
historical_metadata_file <- paste0(metadata_path, "historical_metadata.csv") # http://www.pasteur-guadeloupe.fr/
# Database data
lineage_conversion_file <- paste0(db_path, "lineage_conversions.txt")
dr_genes_file <- paste0(db_path, "tbdb.bed")
# Distance
dist_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist")
dist_id_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist.id")
# Trees
tree_all_samps_newick_file <- paste0(newick_path, "PAKISTAN_ALL.filt.val.gt.g.snps.fa.treefile")
# Beast
beauti_params_file <- paste0(methods_path, "beauti_parameters.csv")
mcc_tree_file <- paste0(beast_results_path, "PAKISTAN_ALL.mcc.tree")
beast_log_file <- paste0(beast_results_path, "PAKISTAN_ALL.dated.log")
beast_clusters_file <- paste0(metadata_path, "PAKISTAN_ALL.clusters.csv")
# Drug resistance
dr_variants_file <- paste0(metadata_path, "PAKISTAN_ALL.variants.dr.txt")
other_variants_file <- paste0(metadata_path, "PAKISTAN_ALL.variants.other.txt")
# Images
tree_all_samps_file <- paste0(plots_path, "PAKISTAN_ALL.tree.png")
beast_clusters_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.beast_clusters.pdf")
dr_trees_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.dr_trees.pdf")
# Map
pakistan_sp_file <- paste0(metadata_path, "pakistan_sp.rds")
pakistan_lat_long_file <- paste0(metadata_path, "pakistan_lat_long.csv")
# Other
methods_file <- paste0(methods_path, "pakistan_methods.tsv")

```

```{r read_in_data, echo = F, warning=F}


# READ IN DATA ----


# Metadata
metadata <- read.csv(metadata_file)
historical_metadata <- read.csv(historical_metadata_file)
# Database data
lineage_conversions <- read.delim(lineage_conversion_file)
dr_genes <- read.delim(dr_genes_file, header = F)
# Dist
dist <- read.delim(dist_file, header = F)
dist_id <- read.delim(dist_id_file, header = F)
# Trees
tree_all_samps <- read.newick(tree_all_samps_newick_file)
# Beast
beauti_params <- read.csv(beauti_params_file)
mcc_tree_ape <- ape::read.nexus(mcc_tree_file)
mcc_tree <- treeio::read.beast(mcc_tree_file)
beast_log <- tracerer::parse_beast_log(beast_log_file)
beast_clusters <- read.csv(beast_clusters_file, header = F, col.names = c("cluster", "id"))
# Drug resistance
dr_variants <- read.delim(dr_variants_file, header = T)
other_variants <- read.delim(other_variants_file, header = T)
# Map
pakistan_sp <- readRDS(pakistan_sp_file)
pakistan_lat_long <- read.csv(pakistan_lat_long_file, header = T)
# Other
methods_table <- read.table(file = methods_file, sep = '\t', header = TRUE)

```

```{r basic-wrangling, echo = F}


# BASIC WRANGLING ----


n_samps_total <- length(metadata$wgs_id)
n_snps_total <- 37970

# Subset metadata to just those with a year
metadata_dated <- subset(metadata, !(is.na(metadata$year)))
dated_samps <- metadata_dated$wgs_id

n_dated_samps <- length(dated_samps)

first_year <- min(metadata_dated$year)
last_year <- max(metadata_dated$year)

cutoff_year <- 50

# -----

# Drugs
n_drugs_total <-ncol(dplyr::select(metadata, rifampicin_test:delamanid_test))

# How many drugs phenotypically tested?
pheno_tests <- dplyr::select(metadata, rifampicin:delamanid)
pheno_test_names <- names(pheno_tests[,apply(pheno_tests, 2, function(x) {!(all(is.na(x)))} )])
n_pheno_tests <- length(pheno_test_names)
pheno_test_names <- gsub('.$', '', paste0(pheno_test_names, ",", collapse = " "))

# ----

# Dated samps
n_dated_samps <- sum(!(is.na(metadata$year)))

# ----

# Publication years
pub_years <- as.numeric(gsub(".*?([0-9]+).*", "\\1", metadata$study_name))


```

```{r wrangle-distance, echo=F}


# DISTANCE ----

# Add row and col names to distance matrix
colnames(dist) <- dist_id[, 1]
row.names(dist) <- dist_id[, 1]
# Divide dist matrix by 2 
dist <- dist/2
# Get lower only
# lower_dist <- dist[lower.tri(dist)]
# dist_dated <- dist[dated_samps, dated_samps]

# Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
dist[upper.tri(dist, diag = T)] <- 0
lower_dist <- dist[lower.tri(dist)]

# Cluster using 'single' method.
# Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
clust <- hclust(as.dist(dist), method = "single")

# Cut tree at threshold to find samples within threshold
clusters <- sort(cutree(clust, h = threshold))

# Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# Gets samples below the threshold
clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
n_clusters_cut_tree <- length(unique(clusters))

# Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
dist_thresh <- as.dist(dist[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.
dist_thresh <- dist_thresh+1 # Add 1 because 1/x later.

```

```{r in-transmission-stats, echo=F}

# Take the samples from the above "clusters" variable - these samples are "in transmission"
# Find their metadata and put into a table
in_trans_metadata <- metadata[metadata[,"wgs_id"] %in% names(clusters), ]

lin <- tab2df(table(in_trans_metadata$main_lineage))
dr <- tab2df(table(in_trans_metadata$dr_status))
dr <- dr[, dr_status_vect]
loc <- tab2df(table(in_trans_metadata$location))

in_trans_df <- data.frame(t(cbind(lin, dr, loc)))
names(in_trans_df) <- "N"
in_trans_df$pc <- (in_trans_df$N/length(clusters))*100

```

```{r dist-sensitivity, echo=F}

# Loop over the SNP dist threshold vector and do the clustering
clusters_list <- list()
for(i in seq(threshold_vect)){
  # Cut tree at threshold to find samples within threshold
  clusters_list[[i]] <- sort(cutree(clust, h = threshold_vect[i]))  
  clusters_list[[i]] <- clusters_list[[i]][clusters_list[[i]] %in% names(which(table(clusters_list[[i]]) > 1)) ]
}

# Get the numbers about the clusters
n_clusts_vect <- unlist(lapply(clusters_list, function(x) length(unique(x))))
n_samps_per_cluster_vect <- unlist(lapply(clusters_list, function(x) length(x)))
med_samps_clusts <- unlist(lapply(clusters_list, function(x) median(table(x))))
min_samps_clusts <- unlist(lapply(clusters_list, function(x) min(table(x))))
max_samps_clusts <- unlist(lapply(clusters_list, function(x) max(table(x))))

# Take the samples that are in the clusters and get all the metadata
metadata_clust_list <- lapply(clusters_list, function(x){
  metadata[metadata[,"wgs_id"] %in% names(x), ]
  })

# Get the lineage stats for the clusters
n_lin_clusts <- data.frame(do.call("rbind", lapply(metadata_clust_list, function(x){
  table(x$main_lineage)
  })))
names(n_lin_clusts) <- paste0("Lin_", 1:ncol(n_lin_clusts))

# Same for dr status
n_dr_clusts <- plyr::rbind.fill(lapply(metadata_clust_list, function(x){
  tab2df(table(x$dr_status))
  }))
n_dr_clusts <- n_dr_clusts[, dr_status_vect] # Re-arrange

dist_sensitivity_table <- data.frame(SNP_dist = threshold_vect, 
                                     N_clusters = n_clusts_vect, 
                                     N = n_samps_per_cluster_vect, 
                                     Median = med_samps_clusts, 
                                     Min = min_samps_clusts, 
                                     Max = max_samps_clusts, 
                                     n_lin_clusts,
                                     n_dr_clusts)

```

```{r wrangle-lineages, echo=F}


# LINEAGES ----


lin_tab <- reshape2::dcast(metadata, main_lineage ~ "N", value.var = id_col, fun.aggregate = length)
names(lin_tab) <- c("Lineages", names(lin_tab)[length(names(lin_tab))])
lin_tab$pc <- round((lin_tab$N/sum(lin_tab$N)) * 100, rnd)


n_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "N"]
pc_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "pc"]
n_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "N"]
pc_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "pc"]
n_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "N"]
pc_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "pc"]
n_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "N"]
pc_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "pc"]


# Lineages conversions
lin_conv <- merge(metadata[c("main_lineage", "sub_lineage")], lineage_conversions, 
                  by.x = "sub_lineage", by.y = "mtbc_lineage", 
                  all.x = T, sort = F)
lin_conv_tab <- reshape2::dcast(lin_conv, sub_lineage + lsp_lineage + spoligotype_family + rd_number ~ "N",
                                value.var = "sub_lineage", fun.aggregate = length)
lin_conv_tab$pc <- (lin_conv_tab$N / sum(lin_conv_tab$N)) * 100
names(lin_conv_tab) <- c("Lineage", "LSP lineage", "Spoligotype family", "Region of difference no.", "N", "%")
lin_conv_tab <- lin_conv_tab[order(lin_conv_tab$N, decreasing = T),]
row.names(lin_conv_tab) <- NULL


```

```{r wrangle-years, echo=F}


# YEARS ----

metadata$year_round <- round(as.numeric(metadata$year, 1))

year_tab <- reshape2::dcast(metadata, year_round ~ "N", value.var = id_col, fun.aggregate = length)
year_tab$pc <- round((year_tab$N/sum(year_tab$N)) * 100, rnd)

```

```{r wrangle-location, echo=F}


# LOCATION ----

metadata$location <- ifelse(metadata$location == "", NA, metadata$location)

location_tab <- reshape2::dcast(metadata, location ~ "N", value.var = id_col, fun.aggregate = length)
location_tab$pc <- round((location_tab$N/sum(location_tab$N)) * 100, rnd)

location_tab <- location_tab[order(location_tab$N, decreasing =T),]

```

```{r wrangle-map, echo = F, message = F, warning = F}

# Not sure what this does
pakistan_sp@data$name <- pakistan_sp@data$NAME_1
# Read in tree again (use ape because read.tree is presumably different to read.newick)
map_tree <- ape::read.tree(tree_all_samps_newick_file)
# Merge lat long data with metadata
metadata <- merge(metadata, pakistan_lat_long, 
                  by = "location", 
                  all.x = T, 
                  sort = F)
# Sort
locations <- metadata[match(map_tree$tip.label, metadata$wgs_id), ]
# Make df of just lat long, sort (not sure the sort is needed), and add rownames
lat_long <- data.frame(lat = locations$lat, long = locations$long)
lat_long <- lat_long[match(map_tree$tip.label, locations$wgs_id), ]
rownames(lat_long) <- map_tree$tip.label
# Colours
regions_uniq <- unique(locations$location)
regions_cols <- rainbow(length(regions_uniq))
map_cols <- matrix(rep(regions_cols[match(locations$location, regions_uniq)], 2),
               nrow(locations), 2, byrow=F)
rownames(map_cols) <- locations$wgs_id

# Subset to complete cases
lat_long <- lat_long[complete.cases(lat_long), ]
tips <- map_tree$tip.label
map_tree <- keep.tip(map_tree, tips[tips %in% row.names(lat_long)])
names(regions_cols) <- regions_uniq
regions_cols <- regions_cols[!(is.na(names(regions_cols)))]
regions_uniq <- regions_uniq[complete.cases(regions_uniq)]

# Do map
obj <- phylo.to.map(map_tree, lat_long, plot = FALSE, database = pakistan_sp, fill=T)


```

```{r wrangle-tree, echo=F}


# TREE ----


tree_all_samps <- midpoint.root(tree_all_samps)

```

```{r wrangle-beast, echo=F}


# BEAST ----


names(beauti_params) <- c("Beauti tab", "Selection", "Parameter values [min, max]")

# Beast clusters
n_beast_clusters <- length(unique(beast_clusters$cluster))
n_beast_cluster_samps <- nrow(beast_clusters)

```

```{r wrangle-DR-basic, echo=F}


# DR ----


# Specific drugs - phenotypic tests (DST)
drugs_data <- apply(metadata[drugs], 2, as.numeric)
dr_tab <- as.data.frame(t(t(apply(drugs_data[, drugs], 2, sum, na.rm = T))))
dst_by_row_vect <- apply(drugs_data[, drugs], 1, sum, na.rm = T)
n_samps_dst_res <- n_samps_total - sum(dst_by_row_vect == 0)
dr_tab$drug_resistance <- row.names(dr_tab)
names(dr_tab) <- c("N", "drug")
dr_tab <- dr_tab[c("drug", "N")]
row.names(dr_tab) <- NULL
dr_tab$pc <- round((dr_tab$N/n_samps_total) * 100, rnd)


# Genotypic DR - TBprofiler
tbp_drug_tests <- grep("_tbp", names(metadata), value = T)
n_tbp_drug_tests <- length(tbp_drug_tests)-2
tbp_data <- ifelse(metadata[tbp_drug_tests] == "-", 0, 1)
tbp_data <- as.data.frame(t(t(apply(tbp_data, 2, sum, na.rm = T))))
tbp_data$drug <- row.names(tbp_data)
row.names(tbp_data) <- NULL
tbp_data <- tbp_data[, c(2, 1)]
names(tbp_data)[2] <- "N"
tbp_data$pc <- round((tbp_data$N/n_samps_total) * 100, rnd)
tbp_data$drug <- gsub("_tbp", "", tbp_data$drug)

# Put DST and TBprofiler results together
dr_tab <- merge(dr_tab, tbp_data, by = "drug", all = T, sort = F)
dr_tab_easy <- dr_tab
names(dr_tab_easy) <- c("drug", "N_dst", "pc_dst", "N_gen", "pc_gen")
names(dr_tab) <- c("Drug", "N DST resistant", "% DST resistant", "N genotypic resistant", "% genotypic resistant")


# DR status
# Desired order of DR cols
dr_vals <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other") 
dr_status_tab <- reshape2::dcast(metadata, dr_status ~ "N", value.var = id_col, fun.aggregate = length)
dr_status_tab <- dr_status_tab[match(dr_vals, dr_status_tab$dr_status), ]
names(dr_status_tab) <- c("Status", names(dr_status_tab)[length(names(dr_status_tab))])
dr_status_tab$pc <- round((dr_status_tab$N/sum(dr_status_tab$N)) *100, rnd)
row.names(dr_status_tab) <- NULL

n_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "N"]
pc_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "pc"]
n_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "N"]
pc_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "pc"]
n_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "N"]
pc_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "pc"]

# DR status by lineage
dr_lin_tab <- reshape2::dcast(metadata,  dr_status ~ main_lineage, value.var = id_col, fun.aggregate = length)
dr_lin_tab$dr_status <- factor(dr_lin_tab$dr_status, levels = dr_vals)
dr_lin_tab <- dr_lin_tab[order(dr_lin_tab$dr_status), ]
names(dr_lin_tab) <- c("DR status", paste0("L", sort(unique(metadata$main_lineage))))
dr_lin_tab <- to_table(dr_lin_tab, pc_dir = "all")
row.names(dr_lin_tab) <- NULL


```

```{r wrangle-discrepancies-other-variants, echo=F}


# DISCREPANCIES ----


FN <- "pheno_res; geno_sens"
FP <- "pheno_sens; geno_res"
discrepancy_data <- metadata[, grep("_test", names(metadata), value = T)]

# How many SAMPLES are FP or FN?
n_FN_samps <- sum(apply(discrepancy_data == FN, 1, sum) > 0) 
n_FP_samps <- sum(apply(discrepancy_data == FP, 1, sum) > 0)

# write.csv(discrepancy_data, file = "../discrepancy_data.csv", row.names = F)

# 177	pheno_res; geno_sens	pheno_res; geno_sens
# 178	match_res	match_res
# 179	match_res	match_res
# 180	match_res	match_res
# 181	match_res	pheno_res; geno_sens

# x <- data.frame(id = LETTERS[1:5], 
#                 rif = c("pheno_res; geno_sens", rep("match_res", 4)), 
#                 iso = c("pheno_res; geno_sens", rep("match_res", 3), "pheno_res; geno_sens"))

# # How many SAMPLES are FP in x? TWO. The answer should be TWO
# sum(apply(x == FN, 1, sum) > 0)
# sum(apply(x, 2, function(x){sum(x == FN)}))

FN_res <- apply(discrepancy_data, 2, function(x){sum(x == FN)})
FP_res <- apply(discrepancy_data, 2, function(x){sum(x == FP)})

discrepancy_data$wgs_id <- metadata$wgs_id # Add ids in for the other variants stuff
# n_FN_samps <- sum(FN_res)
# n_FP_samps <- sum(FP_res)
FN_drugs_split <- names(FN_res[FN_res > 0])
FP_drugs_split <- names(FP_res[FP_res > 0])

# Drug resistance genes lookup table ----

# Convert to one row per drug
names(dr_genes) <- c("chr", "start", "end", "locus", "gene", "drugs")
dr_genes$drugs <- gsub("para-aminosalicylic_acid", "para_aminosalicylic_acid", dr_genes$drugs)
dr_genes <- data.frame(dr_genes %>% 
                         mutate(drugs = strsplit(as.character(drugs), ",")) %>% 
                         unnest(drugs))

dr_genes <- dr_genes[order(dr_genes$drugs), ]


# Other variants ---- 

# Remove Rv3457c locus
other_variants <- other_variants[!(other_variants$locus_tag == "Rv3457c"), ]

# FN
FN_results <- data.frame()
for(i in seq(FN_drugs_split)){
  # Get drug and remove "_test"
  drug <- FN_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FN_samps <- discrepancy_data[discrepancy_data[drug] == FN, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FN_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FN_results <- rbind(ov_sub, FN_results)
}

# TABLE - SUMMARY OF NUMERS - HOW MANY SAMPS 
FN_results_table_pivot <- reshape2::dcast(FN_results, drug + gene + change ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

# Join in total n samps resistant to each drug 
# FN_results_table_pivot <- merge(FN_results_table_pivot, dr_tab_easy[, c("drug", "N_dst", "N_gen")], 
#                                 by = "drug", all.x = T, sort = F)
# 
# # Calc percentages
# FN_results_table_pivot$pc_dst <- (FN_results_table_pivot$N/FN_results_table_pivot$N_dst)*100
# FN_results_table_pivot$pc_gen <- (FN_results_table_pivot$N/FN_results_table_pivot$N_gen)*100
# # Re-order cols
# FN_results_table_pivot <- FN_results_table_pivot[,  c("drug", "gene", "change", "N", "N_dst", "pc_dst", "N_gen", "pc_gen")]

# Other pivots, for easy wrangling:
FN_results_drug_pivot <- reshape2::dcast(FN_results, drug ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

FN_results_gene_pivot <- reshape2::dcast(FN_results, gene ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

# Neaten table 
FN_results_table <- unique(FN_results[, !(names(FN_results) %in% c("locus_tag_drugs", "wgs_id", "id_year", "nucleotide_change"))])
FN_results_table <- FN_results_table[order(FN_results_table$drug, FN_results_table$gene, FN_results_table$genome_pos), ]
row.names(FN_results_table) <- NULL

# FN_results_table[, !(names(FN_results_table) %in% c(""))]

# n_pza_FN_samps <- length(unique(FN_results[FN_results$drug == "pyrazinamide"]$wgs_id))
# pza_FN_mutations <- unique(FN_results[FN_results$drug == "pyrazinamide"]$change)
# pza_FN_mutations_print <- paste0(pza_FN_mutations, collapse = ", ")
# n_pza_FN_mutations <- length(pza_FN_mutations)

# FP 

FP_results <- data.frame()
for(i in seq(FP_drugs_split)){
  # Get drug and remove "_test"
  drug <- FP_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FP_samps <- discrepancy_data[discrepancy_data[drug] == FP, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FP_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FP_results <- rbind(ov_sub, FP_results)
}

# Neaten table
FP_results_table <- unique(FP_results[, !(names(FP_results) %in% c("locus_tag_drugs", "wgs_id", "id_year"))])
FP_results_table <- FP_results_table[order(FP_results_table$drug, FP_results_table$gene, FP_results_table$genome_pos), ]
row.names(FP_results_table) <- NULL


# Get stats

n_FN_drugs <- length(unique(FN_results_table$drug))
n_FP_drugs <- length(unique(FP_results_table$drug))
FN_drugs <- gsub(".{1}$", "", paste0(unique(FN_results_table$drug), sep = ",", collapse = " "))
FP_drugs <- gsub(".{1}$", "", paste0(unique(FP_results_table$drug), sep = ",", collapse = " "))

# Rifampicin
rif_mutations <- subset(FN_results_table, drug == "rifampicin")$change
n_rpob_mutaion_samps <- subset(FN_results_gene_pivot, gene == "rpoB")

# Isoniazid
iso_data <- subset(FN_results_table, drug == "isoniazid")
iso_mutations <- unique(iso_data$change)
iso_genes <- print_vect(unique(iso_data$gene))
n_iso_samps <- length(unique(FN_results[FN_results$drug == "isoniazid", "wgs_id"]))

```

```{r wrangle-dr-variants, echo=F}

dr_variants$locus_tag_drugs <- gsub(c("\\[|\\]|\\'"), "", dr_variants$locus_tag_drugs)
dr_variants$drug <- dr_variants$locus_tag_drugs
dr_variants <- dr_variants[ ,!(names(dr_variants) %in% "locus_tag_drugs")]
# dr_variants_pivot <- reshape2::dcast(dr_variants,  drug ~ gene, value.var = "wgs_id", fun.aggregate = length)

# Tidy up drug col
dr_variants$drug <- ifelse(dr_variants$drug == fq, "fluoroquinolones", 
       ifelse(dr_variants$drug == agc, "aminoglycosides", dr_variants$drug))

# Make pivot table
dr_variants_pivot <- reshape2::dcast(dr_variants, drug + gene + change ~ "N",
                                     value.var = "wgs_id", 
                                     fun.aggregate = function(x){length(unique(x))})

# Merge with totals for each drug

# DST
dr_variants_pivot <- merge(dr_variants_pivot, dr_tab_easy[, c("drug", "N_dst")], 
                           by = "drug", all.x = T, sort = F)
dr_variants_pivot$pc_dst <- (dr_variants_pivot$N/dr_variants_pivot$N_dst)*100
dr_variants_pivot$pc_dst <- ifelse(is.infinite(dr_variants_pivot$pc_dst), NA, dr_variants_pivot$pc_dst)

# Genotype - n.b. this has to be merged from itself because the dr_tab_easy doesn't match the known variants table. 
dr_variants_n <- reshape2::dcast(dr_variants, drug ~ "N_gen", value.var = "wgs_id", 
                                     fun.aggregate = function(x){length(unique(x))})
dr_variants_pivot <- merge(dr_variants_pivot, dr_variants_n, by = "drug", all.x = T, sort = F)
dr_variants_pivot$pc_gen <- (dr_variants_pivot$N/dr_variants_pivot$N_gen)*100

dr_variants_results_table <- unique(dr_variants[, !(names(dr_variants) %in% c("wgs_id", "id_year", "nucleotide_change"))])
dr_variants_results_table <- dr_variants_results_table[order(dr_variants_results_table$drug, 
                                                             dr_variants_results_table$gene, 
                                                             dr_variants_results_table$genome_pos), ]
row.names(dr_variants_results_table) <- NULL

```

```{r wrangle-loc-lin-dr-dates, echo = F}


# TABLE 1 ----


# "Table 1 – locations, lineages, drug resistance, dates of collection…"


table_1 <- data.frame()
table_1 <- rbind(table_1, 
                 setNames(lin_tab, names(table_1)), 
                 setNames(dr_status_tab, names(table_1)), 
                 setNames(dr_tab[, c("Drug", "N genotypic resistant", "% genotypic resistant")], names(table_1)), 
                 setNames(year_tab, names(table_1)), 
                 setNames(location_tab, names(table_1)))

names(table_1) <- c("Characteristic", "N", "%")

table_1$Category <- c(rep("Lineage", nrow(lin_tab)), 
                      rep("DR status", nrow(dr_status_tab)), 
                      rep("Predicted drug resistance", nrow(dr_tab)), 
                      rep("Collection year", nrow(year_tab)),
                      rep("Region", nrow(location_tab)))

table_1 <- table_1[, c( "Category", "Characteristic", "N", "%")]

# table_1 <- table_1[complete.cases(table_1), ]

row.names(table_1) <- NULL



```

```{r ggtree-setup, echo = F}


# GGTREE SETUP ----


# Prep data for heatmaps (strips)

legend_spec <- theme(legend.title = element_text(size = 7),
                     legend.text = element_text(size = 5),
                     legend.key.size = unit(0.3, "cm"))

# Add id/year hybrid col
metadata$id_year <- paste0(metadata$wgs_id, "_", metadata$year)
rownames(metadata) <- metadata$id_year
# heatmap_data <- metadata[metadata$id_year %in% mcc_tree_ape$tip.label,
#                          c("main_lineage", "dr_status"), drop = F]
# Subset metadata
lin_data <- metadata[, "main_lineage", drop = F]
dr_status_data <- metadata[, "dr_status", drop = F]
loc_data <- metadata[, "location", drop = F]
dr_data <- dplyr::select(metadata, rifampicin:delamanid)
dr_tbp_data <- dplyr::select(metadata, rifampicin_tbp:delamanid_tbp)
drug_discrepancy_data <- dplyr::select(metadata, rifampicin_test:delamanid_test)

# Clean location data
loc_data[loc_data == ""] <- NA

# Clean dr_tbp_data
dr_tbp_data[dr_tbp_data != "-"] <- 1
dr_tbp_data[dr_tbp_data == "-"] <- 0

# Convert lin and DR data to factors
dr_data <- data.frame(apply(dr_data, 2, as.factor))
dr_tbp_data <- data.frame(apply(dr_tbp_data, 2, as.factor))
lin_data <- data.frame(apply(lin_data, 2, as.factor))
# drug_discrepancy_data <- data.frame(apply(drug_discrepancy_data, 2, as.factor))

# Change col names
colnames(dr_status_data) <- "DR status"
colnames(lin_data) <- "Lineage"
colnames(loc_data) <- "Location"

# Define cols for each dataset
alpha <- 0.9
lin_colours <- rainbow(length(unique(metadata$main_lineage)), alpha = alpha)
dr_status_colours <- scales::alpha(gplots::col2hex(c("green1", "yellow2", "orange1", "red1", "black", "grey")), alpha = alpha)


n <- length(unique(loc_data$Location))
qual_col_pals <- brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector <- unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
set.seed(2)
loc_cols <- sample(col_vector, n)
names(loc_cols) <- unique(loc_data$Location)
loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

# loc_cols <- randomcoloR::distinctColorPalette(length(unique(loc_data$Location)))
# names(loc_cols) <- unique(loc_data$Location)
# loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
# loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

drug_discrepancy_vals <- sort(unique(as.vector(as.matrix(drug_discrepancy_data))))
drug_discrepancy_cols <- brewer.pal(length(drug_discrepancy_vals), "Paired")

# Add names (unique vals for each dataset) to dataframes. Don't need to do this for the binary data (DR individual status)
names(lin_colours) <- c(sort(unique(metadata$main_lineage)))
names(dr_status_colours) <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other")
names(drug_discrepancy_cols) <- drug_discrepancy_vals

```

| | |
| ----------- | ----------- |
|Gary Napier^1^,* | gary.napier@lshtm.ac.uk |
|Anwar Sheed Khan^2^,^3^,*	|	anwar786kp@hotmail.com |
|Muhammad Tahir Khan^4^ |	muhammad.tahir8@imbb.uol.edu.pk |
|Sajid Ali^2^ | sajidjan@live.com |
|Muhammad Qasim^2^ | qasim@kust.edu.pk |

XXXXX Aga Khan group XXXX	

| | |
| ----------- | ----------- |
|Susana Campino^1^ | susana.campino@lshtm.ac.uk |
|Sajjad Ahmad^5^ | sajjadahmad793@yahoo.com |
|Hazir Rahman^6^ | hazirrahman@hotmail.com |
|Taj Ali Khan^5^,** | tajalikhan.ibms@kmu.edu.pk |
|Jody E. Phelan^1^,** | jody.phelan@lshtm.ac.uk |
|Taane G. Clark^1^,^7^,** | taane.clark@lshtm.ac.uk |

XXX to be confirmed XXX

^1^ Faculty of Infectious & Tropical Diseases, London School of Hygiene & Tropical Medicine, London, UK \
^2^ Department of Microbiology, Kohat University of Science and Technology, Kohat, Pakistan; \
^3^ Provincial Tuberculosis Reference, Laboratory Hayatabad Medical Complex, Peshawar, Pakistan; \
^4^ Institute of Molecular Biology and Biotechnology (IMBB), The University of Lahore. KM, Defense Road, Lahore 58810, Pakistan \
^5^ Institute of Basic medical Science Khyber Medical University, Peshawar KP, Pakistan \
^6^ Department of Microbiology, Abdul Wali Khan University, Mardan, Pakistan \
^7^ Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, London, UK \


\* Joint authors \
\*\* Joint Correspondence: \
Prof. Taane G. Clark, London School of Hygiene & Tropical Medicine, UK; taane.clark@lshtm.ac.uk
Dr. Jody Phelan, London School of Hygiene & Tropical Medicine, UK; jody.phelan@lshtm.ac.uk
Dr. Taj ali Khan, Institute of Basic medical Science Khyber Medical University Peshawar KP Pakistan; tajalikhan.ibms@kmu.edu.pk


## ABSTRACT



## INTRODUCTION

Tuberculosis disease (TB), caused by bacteria in the Mycobacterium tuberculosis (Mtb) complex, is a major global public health problem. Pakistan is a high-burden TB country, being one of eight countries accounting for two-thirds of the global total TB instance (5.7%). In 2019 it had a  total TB incidence of 570,000 and 43,900 deaths [@WHO_2020]. Furthermore, HIV prevalence in the country is increasing (0.1 prevalence 2019), which compounds the problem of TB infections and treatment [@UNAIDS_2020] (5,100 cases and 1,900 HIV-positive mortality cases in 2019). There is also a high burden for multidrug-resistance (MDR-TB, resistance to isoniazid and rifampicin treatments), with 25,000 cases in the latest WHO estimates. 

Whole genome sequencing is revolutionizing our understanding of drug resistance and clinical management, as well as transmission patterns, thereby can assist disease control. Within such a context, it is crucial to monitor transmission patterns and ensure that patients are being treated with optimal drug regimens. Here, we analyse `r n_samps_total` whole genome sequences (WGS) of Pakistan *Mycobacterium tuberculosis* (*Mtb*) samples dating from `r round(first_year)` to `r round(last_year)`, using `r fmt(n_snps_total)` SNPs to infer a timed phylogenetic tree and to predict resistance to `r n_drugs_total` drugs. While our data included phenotypic tests of resistance for `r n_pheno_tests` drugs (`r pheno_test_names`), we also applied genotypic tests of drug resistance using TBprofiler [@Coll2015] to predict drug resistance from a database of ~34,000 WGS samples. The `r n_samps_total` samples were previously published between `r min(pub_years)` and `r max(pub_years)` in `r as.english(length(unique(metadata$study_name)))` different studies. 

Drug resistance and its associated mutation have previously been characterised in samples from Pakistan. Ali (2015) [@Ali2015] investigated XDR isolates across four provinces, and consistent with the present study, most samples (67%) belonged to the Central Asian Strain (CAS) family (lineage 3). Here, SNP mutations were found to be associated to resistance to rifampicin (*rpoB*), isoniazid (*katG* and *inhA*), pyrazinamide (*pncA*), fluoroquinolones (*gyrA*) and aminoglycosides (*rss*). Leading on from this study, Kanji (2017) [@Kanji2017] found increased frequency and expression of novel SNP mutations in efflux pump genes, potentially explaining drug resistance mechanisms. 

Further novel drug-resistance associated mutations were investigated in Jabbar (2019) [@Jabbar2019] in samples from the Khyber Pakhtunkhwa province for 11 anti-TB drugs. Again, the moajority of samples (76.5%) were CAS (lineage 3) samples. Previously unknown mutations were found for ethionamide (*katG* and *ethA*), fluoroquinolones (*gyrA* and *gyrB*) and pyrazinamide (*pncA*). This study also provided evidence of transmission chains in North-West Pakistan: With a standard 10-SNP difference cut-off, there were eight potential transmission clusters formed of 18 drug-resistant samples, concluding that there was support for spread of MDR TB. 

Recently, Qadir (2021) [@Qadir2021] confirmed mutations in the Rifampacin Resistance Determining Region (RRDR) of the *rpoB* gene among 702 Pakistan isolates, and discovered three novel mutations.  


<!--
---

"Characterizing Mycobacterium tuberculosis isolates from Karachi, Pakistan: drug resistance and genotypes"
sciencedirect.com/science/article/pii/S1201971212000276
[@Ayaz2012]

- Resistance rates – new and previously treated:
- MDR-TB: 2.4% and 13.9%
- RIF monoresistance, 0.1% and 0.6%
- Any INH resistance, 8.9% and 28.5%
- INH monoresistance, 3.0% and 6.3%

- Risk factors:
- Prior TB treatment - MDR-TB and INH monoresistance
- Low socioeconomic status - INH monoresistance
- Balouchi, Sindhi or Pakhtun ethnicity for MDR-TB.
- Central Asian strain (55.6%) was the most prevalent genotype
- MDR-TB was significantly associated with Haarlem (H) genogroup

- Conclusions
- An MDR-TB rate of 2.4% is reported in new patients. 
- Low RIF monoresistance supports the use of RIF as a marker for MDR-TB in this population.
- The need to strengthen TB care in the identified at-risk groups is emphasized.
- Based on INH resistance rates, a review of national treatment/prevention regimens relying on INH is suggested.

---

Lit rev:

"Whole Genome Sequencing Based Characterization of Extensively Drug-Resistant Mycobacterium tuberculosis Isolates from Pakistan"
https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0117771#sec002
[@Ali2015]

- Investigated 40 genes associated with drug resistance
- Rifampicin resistance was attributable to SNPs in the rpoB hot-spot region
- Isoniazid resistance was most commonly associated with the katG codon 315 (92%) mutation followed by inhA S94A (8%) 
- However, one strain did not have SNPs in katG, inhA or oxyR-ahpC
- All strains were pyrazimamide resistant but only 43% had pncA SNPs
- Ethambutol resistant strains predominantly had embB codon 306 (62%) mutations, but additional SNPs at embB codons 406, 378 and 328 were also present
- Fluoroquinolone resistance was associated with gyrA 91–94 codons in 81% of strains; four strains had only gyrB mutations, while others did not have SNPs in either gyrA or gyrB
- Streptomycin resistant strains had mutations in ribosomal RNA genes; rpsL codon 43 (42%); rrs 500 region (16%), and gidB (34%) while six strains did not have mutations in any of these genes.
- Amikacin/kanamycin/capreomycin resistance was associated with SNPs in rrs at nt1401 (78%) and nt1484 (3%), except in seven (19%) strains.
- We estimate that if only the common hot-spot region targets of current commercial assays were used, the concordance between phenotypic and genotypic testing for these XDR strains would vary between rifampicin (100%), isoniazid (92%), flouroquinolones (81%), aminoglycoside (78%) and ethambutol (62%); while pncA sequencing would provide genotypic resistance in less than half the isolates. 
- This work highlights the importance of expanded targets for drug resistance detection in MTB isolates.

---

"Single nucleotide polymorphisms in efflux pumps genes in extensively drug resistant Mycobacterium tuberculosis isolates from Pakistan"
https://www.sciencedirect.com/science/article/pii/S1472979216305534?via%3Dihub
[@Kanji2017]

- WGS analysis of 37 XDR and five drug sensitive (DS) MTB isolates
- SNPs in efflux pump genes Rv0194, Rv1217, Rv1218, drrA, drrB, Rv1258, Rv1634, Rv2688, Rv1273, Rv1819, Rv1458, Rv1877 and Rv1250 were determined in the isolate compared with H37Rv
- Frequencies of SNPs identified in XDR strains were compared with DS strains. 
- Gene expression of Rv0194, Rv2688, Rv1634, drrA and drrB was determined in XDR -TB isolates (n=9), DS-TB strains (n=4) and H37Rv.

- We identified SNPs in XDR-TB isolates which were either unique or present at very low frequencies in DS strains; Rv0194 G170V; Rv1217 L151R; Rv1258 P369T and G391R; Rv1273 S118G and I175T; Rv1877 I534T; Rv1250 V318X/A and S333A, and Rv2688 P156T. 
- The expression of Rv2688 and drrB was found to be raised in XDR-TB as compared with DS-TB strains.

- We identified unique SNPs in efflux pump genes which may be associated with increased drug resistance in the isolates. 
- Increased levels of Rv2688 and drrB efflux pump gene expression observed in XDR strains even in the absence of antibiotics suggests that these clinical isolates may be more refractory to treatment.
- Further studies are required to directly associate these mutations with increased resistance in MTB.

---

"Whole genome sequencing of drug resistant Mycobacterium tuberculosis isolates from a high burden tuberculosis region of North West Pakistan"
https://www.nature.com/articles/s41598-019-51562-6
[@Jabbar2019]

- Khyber Pakhtunkhwa province (North West Pakistan), n = 81
- WGS & DST 
- 11 anti-TB drugs. 
- majority CAS/Delhi strain-type (lineage 3; 70.4%) 
- MDR 76.5%)
- Most freq: katG / rpoB - isoniazid / rifampicin
- pncA (pyrazinamide), embB (ethambutol), gyrA (fluoroquinolones), rrs (aminoglycosides), rpsL, rrs and giB (streptomycin) 
- Describe unreported markers: katG, ethA (ethionamide), gyrA and gyrB (fluoroquinolones), and pncA. 
- Analysis of the mutations: acquisition of rifampicin resistance often preceded isoniazid in our isolates.
- High proportion (17.6%) of pre-MDR isolates with fluoroquinolone resistance markers, potentially due to unregulated anti-TB drug use. 
- Our isolates were compared to previously sequenced strains from Pakistan in a combined phylogenetic tree analysis. 
- The presence of lineage 2 was only observed in our isolates. 
- Using a cut-off of less than 10 SNP diffs, a transmission analysis revealed 18 isolates clustering within eight networks, thereby providing evidence of drug-resistant TB transmission in the Khyber Pakhtunkhwa province. 
- Overall: DR TB isolates are circulating and transmitted in North West Pakistan. 
- Further, we have shown the usefulness of whole genome sequencing as a diagnostic tool for characterizing M. tuberculosis isolates, which will assist future epidemiological studies and disease control activities in Pakistan.

---

"Insight into the drug resistance whole genome of Mycobacterium tuberculosis isolates from Khyber Pakhtunkhwa, Pakistan"
https://www.sciencedirect.com/science/article/abs/pii/S1567134821001581
[@Khan2021]

- Aimed to find genomic variations in the first-line drugs targets, along with other virulence and evolutionary factors among the circulating isolates in Khyber Pakhtunkhwa, Pakistan. 
- Some novel mutations have been detected in drugs targets. 
- Similarly, numerous novel variants have also been detected in virulency and evolutionary factors, PE, PPE, and secretory system of MTB isolates. 

---

"Profiling and identification of novel rpoB mutations in rifampicin-resistant Mycobacterium tuberculosis clinical isolates from Pakistan"
https://pubmed.ncbi.nlm.nih.gov/34244055/
[Qadir2021]

RIF resistance has been linked with mutations in rpoB gene. 

- 322 phenotypically RIF-resistant isolates were randomly selected from National TB Reference Laboratory, Pakistan for sequencing 
- while 380 RIF resistance whole-genome sequencing (WGS) of Pakistani isolates (BioProject PRJEB25972), were also analyzed for rpoB mutations.

- 96.1% isolates harbored mutations in rpoB 
- 94.4%) were detected within the RRDR, including three novel. 

Among these mutations, 657 (97.3%) were substitutions including 603 (89.3%) single nucleotide polymorphism, 49 (7.25%) double and five (0.8%) triple. About 94.4% of Phenotypic RIF resistance strains, exhibited mutations in RRDR, which were also detectable by GeneXpert.

Conclusion: Mutations in the RRDR region of rpoB is a major mechanism of RIF resistance in MTB circulating isolates in Pakistan. Molecular detection of drug resistance is a faster and better approach than phenotypic drug susceptibility testing to reduce the time for transmission of RIF resistance strains in population. Such insights will inform the deployment of anti-TB drug regimens and disease control tools and strategies in high burden settings, such as Pakistan.

-->



## RESULTS

### Clinical isolates and phylogeny

A total of `r n_samps_total` *M. tuberculosis* WGS isolates from Pakistan were downloaded from the European Nucleotide Archive (ENA). The samples were cultured, whole-genome sequenced, and drug susceptibility testing (DST) was applied for `r n_pheno_tests` drugs. Combining the results of the DST and the genotypic prediction tests (see **Methods**), `r n_sens` (`r pc_sens`%) samples were pan-sensitive, `r n_mdr` (`r pc_mdr`%) classed as MDR-TB (resistant to both rifampicin and isoniazid), and `r n_xdr` (`r pc_xdr`%) were XDR (resistant to isoniazid and rifampicin, plus any fluoroquinolone and at least one of three injectable second-line drugs). See **Table \@ref(tab:drTableLin)** for Pre-MDR, Pre-XDR figures and drug resistance categories by lineage. 

Upon mapping the sequences, high average coverage was observed across the samples: XXX. A total of `r fmt(n_snps_total)` SNPs were identified, with XXX% found in single isolates. 

Historically, *Mtb* samples from Pakistan belong predominantly to the CAS1-Delhi spoligotype family [@Demay2012], which belongs to Lineage 3 [@Napier2020]. In our samples, Lineage 3 comprises `r lin_tab[lin_tab["Lineages"] == 3, "pc"]`% of the total samples, followed by Lineage 4 (n=`r n_lin_4`, `r pc_lin_4`%), Lineage 2 (n=`r n_lin_2`, `r pc_lin_2`%) and Lineage 1 (n=`r n_lin_1`, `r pc_lin_1`%) (see **Table \@ref(tab:lintable)** for a breakdown of samples by lineage and sublineage and see **Figure \@ref(fig:ggtree-all-samps)** for a full phylogenetic tree). 

### Evidence of transmission

Median (range) pairwise SNP distances was `r round(median(lower_dist), rnd)` (min=`r min(lower_dist)`, max=`r max(lower_dist)`) for all `r n_samps_total` samples (**Figure \@ref(fig:boxdistance)**). For all dated samples (n=`r n_dated_samps`), the median SNP distance was `r round(median(lower_dist), rnd)` (**Figure \@ref(fig:boxdistance)**). With a threshold of `r threshold` SNPs for the dated samples, `r n_clusters_cut_tree` clusters formed, where a cluster contains at least two samples (**Figure \@ref(fig:clusterstree)**). **Figure \@ref(fig:distanceqgraph)** shows a graph of SNP distance connections among all dated samples within the `r threshold`-threshold SNP distance.  


<!--
Date of collection was recorded between the years `r first_year` and `r last_year` (`r last_year - first_year` years) for `r n_dated_samps` samples, which represent probable closely-related, if not potiential transmission cases. A dated phylogenetic tree was constructed with these samples (**Figures \@ref(fig:beasttrees)**), and when cut at `r cutoff_year` years before the last sample date, `r n_beast_clusters` clusters (n=`r n_beast_cluster_samps`) were inferred. 
-->


### Drug susceptibility discrepancies

We identified DSTs that disagreed with the genotypic drug resistance predictions for all samples (n=`r n_samps_total`). These discrepancies were classified into two kinds - where the phenotypic test showed resistance and the genotypic test predicted sensitivity ("false negative" (FN)), and where the phenotypic test result was sensitive but the genotypic test predicted resistance ("false positive" (FP)). Within the clusters defined above, `r n_FN_samps` samples were FN for `r as.english(n_FN_drugs)` drugs (`r FN_drugs`) and `r n_FP_samps` samples were FP for `r n_FN_drugs` (`r FP_drugs`).

For phenotypic DST, there were `r n_samps_dst_res` total samples (`r (n_samps_dst_res/n_samps_total)*100`%) resistant to at least one drug (median = `r median(dst_by_row_vect)`, max = `r max(dst_by_row_vect)`). Among the phenotypic DST results, a high percentage were resistant to four drugs: rifampicin (n=`r dr_tab_easy[dr_tab_easy$drug == "rifampicin", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "rifampicin", "pc_dst"]`%), isoniazid (n=`r dr_tab_easy[dr_tab_easy$drug == "isoniazid", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "isoniazid", "pc_dst"]`%), ethambutol (n=`r dr_tab_easy[dr_tab_easy$drug == "ethambutol", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "ethambutol", "pc_dst"]`%), and pyrazinamide (n=`r dr_tab_easy[dr_tab_easy$drug == "pyrazinamide", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "pyrazinamide", "pc_dst"]`%)

Known drug-resistance mutations were predicted in TB-profiler [@Phelan2019] and compared to the phenotypic DST results for `r n_tbp_drug_tests` distinct drugs (plus fluoroquinolones and aminoglycosides generically). We identified a total of `r sum(discrepancy_data == FP | discrepancy_data == FN)` individual DSTs that disagreed with the genotypic drug resistance predictions in `r n_FN_samps+n_FP_samps` samples (**Table \@ref(tab:dr-tab)**; the other discrepancies here are explained by the unavailability of phenotypic DST data). Of these samples, `r n_FN_samps` were FN, and `r n_FP_samps` samples vice versa (FP).

### Mutations potentially exlpaining drug-resistance

For FN samples, **Table \@ref(tab:FNresultstable)** shows all variants found in drug resistance-associated genes for `r n_FN_drugs` drugs (`r FN_drugs`), that were previously unknown to be associated with each respective drug, potentially explaining discrepancies between phenotypic DST results and genotypic predictions. 

<!--
#### Rifampicin

`r tools::toTitleCase(as.character(as.english(length(rif_mutations))))` mutations were associated with changes to the *rpoB* gene/Rv0667 locus: one in a non-coding region, one insertion and two deletions (n=`r n_rpob_mutaion_samps`). 

#### Isoniazid 

Among isoniazid-associated genes, `r length(unique(iso_mutations))` previously-unknown mutations were found among `r as.english(length(unique(iso_data$gene)))` genes (`r iso_genes`) (n=`r n_iso_samps`). 
-->




## DISCUSSION


## METHODS

<!--
```{r methods, echo=FALSE, out.width = "1500px"}

kable(methods_table)

```
-->

### Sequence data and processing

WGS were sourced across `r as.english(length(unique(metadata$study_name)))` studies [@Stucki2016] [@Phelan2016a] [Cryptic2018] [Coll2018][@Jabbar2019][@Khan2021](ENA accessions: PRJEB7798, PRJEB10385, PRJEB25972, PRJEB32684, PRJEB43284). 

Sequences were downloaded from the European Nucleotide Archive (ENA www.ebi.ac.uk/ena/) and quality inspection of reads assessed in fastQC (version 0.11.9, www.bioinformatics.babraham.ac.uk/projects/fastqc/). Raw reads were trimmed to remove low-quality sequences in Trimmomatic v0.39 [@Bolger2014] and aligned to the H37Rv reference genome (AL123456) with BWA mem v0.7.17 [@Li2013], [@Cole1998]. 

Joint SNP calling was processed in gatk GenotypeGVCFs v4.1.3.0 [@Depristo2011]. SNP filtering excluded indels, heterozygous SNPs, monomorphic SNPs and non-unique regions of the genome (e.g. PE/PPE genes), which was conducted in bcftools v1.9 [@Li2009]. 

A multi-FASTA format file was created from the filtered SNP file and H37Rv reference fasta using bedtools makewindows v2.28.0 [@Quinlan2010] which in turn was used to construct a phylogenetic tree with IQ-TREE v1.6.12. Here, a general time reversible model with rate heterogeneity set to a discrete Gamma model and an ascertainment bias correction were used (parameters -m GTR+G+ASC), with 1000 bootstrap samples used to measure branch quality and robustness. [@Nguyen2015] [@Hoang2018] [@Tavare1986] [@Lewis2001] [@Yang1994].

Pairwise distance matrices were calculated in Plink v1.90b4 [@Purcell2007]. Drug resistance status, drug resistance-associated mutations, other mutations, and lineages were predicted *in silico* using TB-Profiler v2.4 [@Phelan2019] [@Coll2015] [@Napier2020]. In categorising samples as *Susceptible*, *Pre-MDR*, *MDR*, *Pre-XDR*, *XDR*, or *other*, the TB-Profiler predictions were used in place of missing or contradictory DST data. 

<!--

BEAST v2.6.3 [@Bouckaert2019] was used to infer timed phylogenetic trees (see **Table \@ref(tab:beautiparams)** for parameters and settings). From the high ESS values (**Table \@ref(tab:beastlogtable)**) and the non-directional trace plots in (**Figure \@ref(fig:beastlogplots)**), effective sample size seems satisfactory and parameters have converged.

-->

***

### Tables

#### General
```{r table-1, echo=FALSE, out.width = "2000px"}

knitr::kable(table_1, row.names = NA, rownames.print = F, caption = sprintf("*Mycobacterium tuberculosis* samples (N = %s)", n_samps_total))

```
***
#### Lineages
```{r lintable, echo=FALSE, out.width = "2000px"}

# knitr::kable(lin_tab, align = align)
# cap <- "Table of main sublineages as proposed by Comas et al (2010) [@Comas2010] and Stucki et al (2016) [@Stucki2016] and predicted by Napier (2020) [@Napier2020], and their equivalents in 'Large Sequence Polymorphism' lineages[@GagneuxDeRiemer2006] and spoligotype families[@Demay2012]."
cap <- "Strain-types"
knitr::kable(lin_conv_tab, caption = cap)

```
***
#### Transmission
```{r in-trans-table, echo=FALSE, out.width = "2000px"}

knitr::kable(in_trans_df, 
             caption = sprintf("Lineages, drug-resistance status and locations of samples 'in transmission' - i.e. a SNP distance of %s (n=%s)", threshold, length(clusters)))

```
***
```{r dist-sens-table, echo=FALSE, out.width = "2000px"}

knitr::kable(dist_sensitivity_table, caption = "Sensitivity analysis of clustering by SNP distance, summary statistics")

```
***
#### Drug resistance
```{r drTableLin, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_lin_tab, row.names = NA, rownames.print = F, caption = "Drug resistance categories by lineage. See *Methods* section for criteria of categories.")

```
***
```{r dr-tab, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_tab, caption = "Numbers and percentages of drug-resistant samples accourding to DST and genotypic predictions (TBprofiler)")

```
***
```{r dr-variants-table, echo=FALSE, out.width = "2500px"}

knitr::kable(dr_variants_pivot, 
             caption = sprintf("Number of samples with known drug resistance-associated mutations by gene and drug (n=%s)", n_samps_total))

```
***
```{r FNresultstable, echo=FALSE, out.width = "2500px"}

knitr::kable(FN_results_table_pivot, caption = sprintf("Number of samples with variants previously unknown to be associated with drug resistance (for each respective drug) among 'FN' drug susceptibility test samples (n=%s)", n_FN_samps) )

```
***

<!--
#### Beast
```{r beautiparams, echo=FALSE, out.width = "2000px"}

knitr::kable(beauti_params, caption = "Settings in Beauti for BEAST analysis. Parameters & priors are based on Xu (2020) [@Xu2020]")

```
***
```{r beastlogtable, echo=FALSE, out.width = "1500px"}

# Results of beast log

# Remove the burn-in
beast_log <- tracerer::remove_burn_ins(
  beast_log,
  burn_in_fraction = 0.1
)

# Calculates the effective sample sizes of all parameter estimates
esses <- t(tracerer::calc_esses(beast_log, sample_interval = 1000))

# Get means
means <- apply(beast_log, 2, mean)
means <- means[!(names(means) %in% "Sample")]

# Combine
log_table <- cbind(means, esses)
colnames(log_table) <- c("Mean", "ESS")
log_table <- round(log_table, 2)

knitr::kable(log_table, caption = "Mean and effective sample size (ESS) outputs from BEAST for tree parameter posteriors.")

```
***
-->

### Figures

<!--
```{r historical, fig.cap = sprintf("Number of samples by spoligotype family \n in historical Mtb data from Pakistan [@Demay2012], n = %s", n_samps_historical) , echo=FALSE, out.width = "2000px"} 

n_samps_historical <- length(historical_metadata$IsoNumber)

barplot(table(historical_metadata$Clade), las=2, main = "", col = col, cex.axis = 0.5, cex.names=0.75)

```
-->
***
<!--
```{r treeAllSamps, echo=FALSE, out.width = "2000px", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total)) }

cap <- sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))

knitr::include_graphics(tree_all_samps_file)

```
-->
***

```{r ggtree-all-samps, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))}

# Tree setup
line_sz <- 0.25
n <- length(tree_all_samps$tip.label)
width <- 0.1
angle <- 45

# Remove years from lineage data
lin_data_no_year <- lin_data
row.names(lin_data_no_year) <- unlist(lapply(strsplit(row.names(lin_data_no_year), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from DR data 
row.names(dr_status_data) <- unlist(lapply(strsplit(row.names(dr_status_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from location data
row.names(loc_data) <- unlist(lapply(strsplit(row.names(loc_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))


ggtree_all_samps <- ggtree(tree_all_samps, size = line_sz, layout="circular")

# Add lin data
lin_hm <- gheatmap(ggtree_all_samps, lin_data_no_year,
         width = width,
         # offset = offset,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle, 
         colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) ) +
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = width * 0.025,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR status")+
  legend_spec

# dr_status_hm

dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

gheatmap(dr_status_hm, loc_data,
                   width = width,
                   offset = width * (0.025*2),
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = loc_cols, breaks = names(loc_cols), na.value="white")+
  labs(fill = "Location")+
  legend_spec

```
***
```{r dr-trees, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=""}

# -------------
# Add DR stuff 
# -------------

# Tree setup
width <- 0.02
n_samps <- length(tree_all_samps$tip.label)
y_lim <- c(-5, n_samps + (n_samps * 0.1))
font_sz <- 2
width <- 0.05
angle <- 45
line_sz <- 0.2

# Draw basic tree
gg_dr_tree <- ggtree(tree_all_samps, size = line_sz) +
  coord_cartesian(ylim = y_lim) 
  # scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim) +
  # theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))

lin_hm <- gheatmap(gg_dr_tree, lin_data_no_year,
         width = width,
         # offset = offset,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle, 
         colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) ) +
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = width * 0.025,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours)) +
  labs(fill = "DR status")+
  legend_spec

# dr_status_hm

dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

lin_dr_loc_hm <- gheatmap(dr_status_hm, loc_data,
                   width = width,
                   offset = width * (0.025*2),
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = loc_cols, breaks = names(loc_cols), na.value="white")+
  labs(fill = "Location")+
  legend_spec

lin_dr_loc_hm <- lin_dr_loc_hm + ggnewscale::new_scale_fill()


# Drug resistance - DST

# Strip date
row.names(dr_data) <- unlist(lapply(strsplit(row.names(dr_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))
# pdf(file = dr_trees_pdf_file)
gheatmap(lin_dr_loc_hm, dr_data,
         offset = width * (0.025*3),
         width = width+0.5,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

# Drug resistance from TB profiler (genotypic drug resistance predictions)
# Strip dates from dr_tbp_data
row.names(dr_tbp_data) <- unlist(lapply(strsplit(row.names(dr_tbp_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))
gheatmap(lin_dr_loc_hm, dr_tbp_data,
         offset = width * (0.025*3),
         width = width+0.5,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec


# Drug discrepancy
# Strip date

row.names(drug_discrepancy_data) <- unlist(lapply(strsplit(row.names(drug_discrepancy_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))
gheatmap(lin_dr_loc_hm, drug_discrepancy_data,
         offset = width * (0.025*3),
         width = width+0.5,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec


```

***

```{r map, echo=FALSE, out.width = "2000px", fig.cap=sprintf("Locations of samples; n = %s", length(obj$tree$tip.label))}

plot(obj, lty = 1, fsize = 0.01, direction = "rightwards", colors = map_cols, pch=20)
legend("bottomright", legend = regions_uniq, fill = regions_cols, cex = 0.75)

```

***
<!--
```{r dates, echo=FALSE, out.width = "2000px", fig.cap=sprintf("Histogram of sample collection year; n = %s", n_dated_samps)}

# year <- round(as.numeric(metadata$year[!is.na(metadata$year)], 1))
# years <- sort(unique(year))
# breaks <- (min(year)-0.5):(max(year)+0.5)
# yr_hist <- hist(year, freq = T, xaxt="n", xlab= "year",
#                 breaks = breaks, col = col, main = "")
# axis(side = 1, at = yr_hist$mids, labels = years)

```
-->
***

```{r boxdistance, echo=FALSE, fig.show="hold", out.width="50%", fig.cap = sprintf("Boxplot of pairwise SNP distances (excluding DR sites), all samples (left; n = %s), samples within %s SNP distance (right; n = %s).", nrow(dist), threshold, nrow(as.matrix(dist_thresh)))}

# Summary of distances for all samples
# lower_dist <- dist[lower.tri(dist)]
boxplot(lower_dist, 
    col = col, 
    main = sprintf("mean = %s; median = %s", round(mean(lower_dist), rnd), round(median(lower_dist), rnd) ), 
    cex.main = main_cex, 
    ylab="SNP distance")

# Summary of dists for threshold (clustered) samples
# dist_dated <- dist[dated_samps, dated_samps]
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
boxplot(dist_thresh, col = col,
        main = sprintf("mean = %s; median = %s", round(mean(dist_thresh), rnd), round(median(dist_thresh), rnd) ),
        cex.main = main_cex,
        ylab="SNP distance")

```

***

```{r clusterstree, echo = F, out.width = "2000px", fig.cap = sprintf("Single linkage tree of SNP distances, dated samples. Line shown at a SNP distance of %s; n = %s; n clusters = %s", threshold, nrow(dist), n_clusters_cut_tree)}

# # dist_dated <- as.dist(dist_dated)
# 
# # Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# 
# # Cluster using 'single' method.
# # Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
plot(clust, labels = F, xlab = "", main = "")
abline(a = threshold, b = 0)
# # Cut tree at threshold to find samples within threshold
# clusters <- sort(cutree(clust, h = threshold))
# 
# # Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# # Gets samples below the threshold
# clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
# 
# n_clusters_cut_tree <- length(unique(clusters))
# 
# # Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.

```

***

```{r distanceqgraph, echo=FALSE, out.width = "2000px", fig.cap = sprintf("Graph of samples. Connections among samples with <= %s SNP distance; n = %s. Thicker lines indicate smaller SNP distance.", threshold, length(attributes(dist_thresh)$Labels)), fig.show="hold"}

# qgraph::qgraph(1/dist_dated_thresh, layout='spring', vsize=5)

# Subset
# lin_data_qgraph <- lin_data[row.names(lin_data) %in% attributes(dist_dated_thresh)$Labels, "Lineage", drop = F]
lin_data_qgraph <- lin_data_no_year[row.names(lin_data_no_year) %in% attributes(dist_thresh)$Labels, "Lineage", drop = F]
# Add sample names to df
lin_data_qgraph$samp <- row.names(lin_data_qgraph)
# Convert to DM for easy access to row and col names
# dist_mat <- as.matrix(dist_dated_thresh)
dist_mat <- as.matrix(dist_thresh)
# Get the row index for each samp in the DM
dist_samp_ind <- data.frame(samp = row.names(dist_mat), row = seq(row.names(dist_mat)))
# Merge with lin data
lin_data_qgraph <- merge(dist_samp_ind, lin_data_qgraph,
                         by = "samp", 
                         sort = F)
# Split by lin
lin_data_split <- split(lin_data_qgraph, lin_data_qgraph$Lineage)
# Loop over split df and replace lists with row nums
for(i in seq(lin_data_split)){
  lin_data_split[[i]] <- lin_data_split[[i]]$row
}

# Edge thickness
cut_val <- 0.5
# Node size
vsize_val <- 2

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = lin_data_split, 
               legend = TRUE, 
               color = lin_colours)


# Same for DR data
dr_status_data_qgraph <- dr_status_data[row.names(dr_status_data) %in% attributes(dist_thresh)$Labels, "DR status", drop = F]
dr_status_data_qgraph$samp <- row.names(dr_status_data_qgraph)
dr_data_qgraph <- merge(dist_samp_ind, dr_status_data_qgraph,
                         by = "samp", 
                         sort = F)
dr_data_split <- split(dr_data_qgraph, dr_data_qgraph["DR status"])
# Re-arrange order to match col vector
dr_data_split <- dr_data_split[names(dr_status_colours)]

for(i in seq(dr_data_split)){
  dr_data_split[[i]] <- dr_data_split[[i]]$row
}

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = dr_data_split, 
               legend = TRUE, 
               color = dr_status_colours)

# Location
loc_data_qgraph <- loc_data[row.names(loc_data) %in% attributes(dist_thresh)$Labels, "Location", drop = F]
loc_data_qgraph$samp <- row.names(loc_data_qgraph)
loc_data_qgraph <- merge(dist_samp_ind, loc_data_qgraph,
                         by = "samp", 
                         sort = F)
# Convert NA to something else
loc_data_qgraph[is.na(loc_data_qgraph$Location), "Location"] <- "N/A"
# Do the same for col
names(loc_cols)[is.na(names(loc_cols))] <- "N/A"
loc_data_split <- split(loc_data_qgraph, loc_data_qgraph["Location"], drop = T)

# Subset so that next line does not contain NAs (does for some reason if don't match)
loc_cols_qgraph <- loc_cols[names(loc_cols) %in% names(loc_data_split)]
# Re-order split-df to same order as loc vector
loc_data_split <- loc_data_split[names(loc_cols_qgraph)]

for(i in seq(loc_data_split)){
  loc_data_split[[i]] <- loc_data_split[[i]]$row
}

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = loc_data_split, 
               legend = TRUE, 
               color = loc_cols_qgraph)

  
```

***

```{r n-clusters-plot, echo = F, out.width = "2000px", fig.cap = "Number of clusters (top) and number of samples in each cluster (bottom), per SNP distance threshold (1 - 50 SNPs)", fig.show="hold"}

plot(threshold_vect, n_clusts_vect, type = 'l', xaxt = "n", xlab = "SNP distance threshold", ylab = "n clusters")
axis(1, at = threshold_vect, las = 2)
plot(threshold_vect, n_samps_per_cluster_vect, type = 'l', xaxt = "n", xlab = "SNP distance threshold", ylab = "n clustering samples")
axis(1, at = threshold_vect, las = 2)

```

***

<!--

```{r beasttrees, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap="Timed phylogenetic trees of all dated samples (n = n_dated_samps), inferred from BEAST. A - Timed phylogenetic tree annotated with drug resistance statuses from phylogenetic tests (DST); B - The same tree annotated with drug resistance statuses from genotypic profiling (TBprofiler); C - Annotated with the discrepancies between the phenotypic and genotypic tests."}


# Get first date from tree (i.e. date of the root)
# first_date <- mcc_tree_ape$root.edge
first_date <- log_table[grep("mrca.date", row.names(log_table))]
first_date <- plyr::round_any(first_date, 10)


first_date <- 0

# Get last date from the samples
last_date <- as.numeric(max(unlist(lapply(strsplit(mcc_tree_ape$tip.label, "_"), function(x){x[length(x)]}))))
last_date_chr <- paste0(as.character(ceiling(last_date)), "-12-31")
n_samps <- length(mcc_tree_ape$tip.label)

# Tree setup
x_lim <- c(first_date-10, last_date+(last_date*0.8))
y_lim <- c(-5, n_samps + (n_samps * 0.1))
v_line_col <- "red"
x_labs_full <- seq(first_date, last_date, by = 100)
x_labs_zoom <- seq(last_date-50, last_date, by = 1)
offset <- 50
width <- 0.05
angle <- 45
line_sz <- 0.2




# x <- mcc_tree
# x <- as.phylo(x)
# x <- phyclust::rescale.rooted.tree(x, scale.height = 1)
# ggtree(x, mrsd = last_date_chr, size = line_sz) +
#   theme_tree2() +
#   scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)





# Draw basic tree
gg_mcmc_tree <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) +
  theme_tree2() +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  # geom_range("length_0.95_HPD", color='red', size=2, alpha=.5) +
  # geom_text2(aes(label=round(as.numeric(posterior), 2),
  #                subset=as.numeric(posterior)> 0.9,
  #                x=branch), vjust=0) +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim) +
  theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree, lin_data,
         width = width,
         offset = offset, color = NULL,
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = offset+100, color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR status")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

width_plus <- 0.6
font_sz <- 2

# pdf(file = dr_trees_pdf_file)
gheatmap(dr_status_hm, dr_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

# Drug resistance from TB profiler (genotypic drug resistance predictions)

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset+200,
         width = width + width_plus,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

```
-->

***

<!--
```{r beasttreeszoom, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The same trees and annotations as Figure \\@ref(fig:beasttrees), zoomed in to the last 50 years before the last sample date. Samples which do not form a cluster (the MRCA was before 50 years or there is only one sample) have been dropped. n = %s",  n_beast_cluster_samps)}

# Zoom in to clusters

# Zoom tree setup
zoom_range <- c((last_date+1) - 50, (last_date + 1) + 65)
zoom_range_seq <- seq(zoom_range[1], (last_date+1), 2)

offset_zoom <- 0
width_zoom <- 0.0015

gg_mcmc_tree_zoom <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) %<+% metadata +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  geom_tiplab(align=T, size = 1.5, linetype=NA, hjust = -3.9)+
  theme_tree2() +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = zoom_range_seq,
                    labels = zoom_range_seq,
                    limits = zoom_range) +
  # scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)+
  geom_vline(aes(xintercept = 2020), col = "red")+
  # geom_tiplab(align = TRUE, linetype='dashed', linesize=.3, size = 2) +
  theme(axis.text.x = element_text(face = "bold", size = 6, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree_zoom, lin_data,
                   width = width_zoom,
                   offset = offset_zoom,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                         width = width_zoom,
                         offset = offset_zoom + 2.5,
                         color = NULL,
                         colnames_position = "top",
                         colnames_angle = angle, colnames_offset_y = 1,
                         hjust = 0,
                         font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR\nstatus")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()
offset_zoom_plus <- 6

gheatmap(dr_status_hm, dr_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

# dev.off()

# # Loop through clusters
# 
# clusters_split <- split(beast_clusters, beast_clusters$cluster)
# mcc_tree_tips <- mcc_tree@phylo$tip.label
# 
# # pdf(file = beast_clusters_pdf_file)
# for(i in seq(clusters_split)){
# 
#   names_to_keep <- clusters_split[[i]]$id
#   names_to_drop <- mcc_tree_tips[!(mcc_tree_tips %in% names_to_keep)]
#   clust_tree <- treeio::drop.tip(mcc_tree, names_to_drop)
# 
#   # Do tree first to get first and last date
#   last_date_clust <- as.numeric(max(unlist(lapply(strsplit(clust_tree@phylo$tip.label, "_"), function(x){x[length(x)]}))))
#   last_date_clust_chr <- paste0(as.character(last_date), "-12-31")
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2()
#   last_date_clust <- ceiling(max(gg_clust_tree$data$x))
#   first_date_clust <- floor(min(gg_clust_tree$data$x))
# 
#   n_samps <- length(clust_tree@phylo$tip.label)
#   last_date_clust_chr <- paste0(last_date_clust-1, "-12-31")
#   date_range_clust <- c(first_date_clust, last_date_clust)
#   year_span_clust <- diff(date_range_clust)
#   oom <- log10_ceiling(year_span_clust)
#   if(oom == 1){
#     by <- 1
#   }else if(oom == 10){
#     by <- 2
#   }else if(oom == 100){
#     by <- 10
#   }else{
#     by <- 100
#   }
#   zoom_range_seq_clust <- seq(first_date_clust,
#                               last_date_clust,
#                               by = by)
# 
#   post_tree_multiply <- 5
#   post_tree_span <- (year_span_clust * post_tree_multiply)
#   x_lim_clust <- c(first_date_clust - (year_span_clust*0.2), last_date_clust + post_tree_span)
#   y_lim_clust <- c(0 - floor(n_samps*0.1),  n_samps + ceiling(n_samps*0.2) )
#   # width <- width * (p$data$x %>% range(na.rm = TRUE) %>% diff)/ncol(data)
#   width_clust <- 0.035 * post_tree_multiply  # % of tree time span
#   # offset_clust <- (width_clust * year_span_clust) + ((width_clust * year_span_clust)*0.1)
#   offset_clust <- (width_clust * year_span_clust)
# 
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2() +
#     coord_cartesian(ylim = y_lim_clust) +
#     scale_x_continuous(breaks = zoom_range_seq_clust,
#                        labels = zoom_range_seq_clust,
#                        limits = x_lim_clust) +
#     geom_vline(aes(xintercept = last_date_clust), col = "red")+
#     theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))
# 
# # Add lin data
# lin_hm_clust <- gheatmap(gg_clust_tree, lin_data,
#                    width = width_clust,
#                    offset = 0,
#                    color = NULL,
#                    colnames_position = "top",
#                    colnames_angle = angle,
#                    # colnames_offset_y = 1,
#                    hjust = 0,
#                    font.size = 3) +
#   scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
#   labs(fill = "Lineage")
# 
# lin_hm_clust <- lin_hm_clust + ggnewscale::new_scale_fill()
# 
# # Add DR status clusters
# dr_status_hm_clust <- gheatmap(lin_hm_clust, dr_status_data,
#                          width = width_clust,
#                          offset = offset_clust,
#                          color = NULL,
#                          colnames_position = "top",
#                          colnames_angle = angle,
#                          # colnames_offset_y = 1,
#                          hjust = 0,
#                          font.size = 3) +
#   scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
#   labs(fill = "DR\nstatus")
# 
# dr_status_hm_clust <- dr_status_hm_clust + ggnewscale::new_scale_fill()
# 
# final_plot <- gheatmap(dr_status_hm_clust, dr_data,
#          width = width_clust * ncol(dr_data),
#          # offset = ceiling(offset_clust * 3),
#          offset = (offset_clust * 2) + (offset_clust * 0.2),
#          # color = NULL,
#          low="white", high="black", color="black",
#          colnames_position = "top",
#          colnames_angle = angle,
#          colnames_offset_y = 0,
#          hjust = 0,
#          font.size = 2.5,
#          legend_title = "llw") +
#   scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
#   labs(fill = "Drug\nresistance")
# 
# print(final_plot)
# }
# # dev.off()


```
-->

***

<!--
```{r beastlogplots, echo=FALSE, out.width = "1500px", fig.cap = "Trace plots of BEAST MCMC iterations across posterior, likelihood, prior and MRCA parameters. The plots show no upward or downward trend, hence imply convergence."}

par(mfrow = c(2, 2))

plot(beast_log$posterior, main = "posterior", type= 'l', ylab = "posterior")
plot(beast_log$likelihood, main = "likelihood", type= 'l', ylab = "likelihood")
plot(beast_log$prior, main = "prior", type= 'l', ylab = "prior")
plot(beast_log$mrca.date.forward.TreePrior., main = "MRCA", type= 'l', ylab = "MRCA")

par(mfrow=c(1,1))

```
-->

### References













