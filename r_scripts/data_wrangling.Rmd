---
title: "Characterisation of drug-resistant Mycobacterium tuberculosis mutations and transmission in Pakistan"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE}

# SETUP ----

knitr::opts_chunk$set(echo = F)
library(knitr)
library(dplyr)
library(tidyr)
library(janitor)
library(qgraph)
library(ape)
library(phytools)
library(coda)
library(ggplot2)
library(ggtree)
library(treeio)
library(scales)
library(gplots)
library(RColorBrewer)
library(randomcoloR)
library(usedist)
library(phytools)
library(sp)
knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r functions, echo = F}

# FUNCTIONS ----

heaD <- function(x,...){
  head(x, ...)
}

fmt <- function(x, ...){format(x, big.mark=",",scientific=FALSE, ...)}

len_str <- function(string){
  length(unlist(strsplit(string, split = "")))
}

hs <- function(x, ...){
  print(head(x, ...))
  print("---")
  str(x, ...)
}

to_table <- function(x, pc_dir = "row"){
  # pc_dir = the direction to use for calculating percentages. One of "row", "col", or "all".
  x <- x %>% adorn_totals(c("row", "col")) %>%
    adorn_percentages(c(pc_dir)) %>%
    adorn_pct_formatting(digits = 2)
  formatted_ns <- attr(x, "core") %>% # extract the tabyl's underlying Ns
    adorn_totals(c("row", "col")) %>% # to match the data.frame we're appending to
    dplyr::mutate_if(is.numeric, format, big.mark = ",")
  x %>% adorn_ns(position = "front", ns = formatted_ns)
}

log10_ceiling <- function(x) {
  10^(ceiling(log10(x)))
}

plot.phylo.to.map <- function (x, type = c("phylogram", "direct"), ...) 
{
  type <- type[1]
  if (class(x) == "phylo.to.map") {
    tree <- x$tree
    map <- x$map
    coords <- x$coords
  }
  else stop("x should be an object of class \"phylo.to.map\"")
  if (hasArg(xlim)) 
    xlim <- list(...)$xlim
  else xlim <- map$range[1:2]
  if (hasArg(ylim)) 
    ylim <- list(...)$ylim
  else ylim <- map$range[3:4]
  if (hasArg(fsize)) 
    fsize <- list(...)$fsize
  else fsize <- 1
  if (hasArg(split)) 
    split <- list(...)$split
  else split <- c(0.4, 0.6)
  if (hasArg(psize)) 
    psize <- list(...)$psize
  else psize <- 1
  if (hasArg(cex.points)) {
    cex.points <- list(...)$cex.points
    if (length(cex.points) == 1) 
      cex.points <- c(0.6 * cex.points, cex.points)
  }
  else cex.points <- c(0.6 * psize, psize)
  if (hasArg(mar)) 
    mar <- list(...)$mar
  else mar <- rep(0, 4)
  if (hasArg(asp)) 
    asp <- list(...)$asp
  else asp <- 1
  if (hasArg(ftype)) 
    ftype <- list(...)$ftype
  else ftype <- "reg"
  ftype <- which(c("off", "reg", "b", "i", "bi") == ftype) - 
    1
  if (!ftype) 
    fsize = 0
  if (hasArg(from.tip)) 
    from.tip <- list(...)$from.tip
  else from.tip <- FALSE
  if (hasArg(colors)) 
    colors <- list(...)$colors
  else colors <- "red"
  if (length(colors) == 1) 
    colors <- rep(colors[1], 2)
  if (length(colors) == 2 && type == "phylogram") {
    colors <- matrix(rep(colors, nrow(coords)), nrow(coords), 
                     2, byrow = TRUE)
    rownames(colors) <- rownames(coords)
  }
  if (hasArg(direction)) 
    direction <- list(...)$direction
  else direction <- "downwards"
  if (hasArg(pch)) 
    pch <- list(...)$pch
  else pch <- 21
  if (length(pch) == 1) 
    pch <- rep(pch, 2)
  if (hasArg(lwd)) 
    lwd <- list(...)$lwd
  else lwd <- c(2, 1)
  if (length(lwd) == 1) 
    lwd <- rep(lwd, 2)
  if (hasArg(lty)) 
    lty <- list(...)$lty
  else lty <- "dashed"
  if (hasArg(pts)) 
    pts <- list(...)$pts
  else pts <- TRUE
  if (type == "phylogram") {
    if (direction == "downwards") {
      if (!ftype) 
        ylim <- c(ylim[1], ylim[2] + 0.03 * diff(ylim))
      ylim <- c(ylim[1], ylim[2] + split[1]/split[2] * 
                  (ylim[2] - ylim[1]))
    }
    else if (direction == "rightwards") {
      if (!ftype) 
        xlim <- c(xlim[1] - 0.03 * diff(xlim), xlim[2])
      xlim <- c(xlim[1] - split[1]/split[2] * (xlim[2] - 
                                                 xlim[1]), xlim[2])
    }
  }
  par(mar = mar)
  plot.new()
  plot.window(xlim = xlim, ylim = ylim, asp = asp)
  map(map, add = TRUE, fill = TRUE, col = "black", border="grey", mar = rep(0, 
                                                                            4))
  if (type == "phylogram") {
    cw <- reorder(tree, "cladewise")
    n <- Ntip(cw)
    if (direction == "downwards") {
      dx <- abs(diff(xlim))
      rect(xlim[1] - 1.04 * dx, ylim[2] - split[1] * (ylim[2] - 
                                                        ylim[1]), xlim[2] + 1.04 * dx, ylim[2], col = "white", 
           border = "white")
      pdin <- par()$din[2]
      sh <- (fsize * strwidth(paste(" ", cw$tip.label, 
                                    sep = "")) + 0.3 * fsize * strwidth("W")) * (par()$din[1]/par()$din[2]) * 
        (diff(par()$usr[3:4])/diff(par()$usr[1:2]))
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (ylim[2] - ylim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      x <- vector(length = n + cw$Nnode)
      x[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (xlim[2] - xlim[1]) + xlim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        xx <- x[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        x[nn[i]] <- mean(range(xx))
      }
      Y <- ylim[2] - nodeHeights(cw)
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(x[i], coords[i, 1]), c(Y[which(cw$edge[, 
                                                                    2] == i), 2] - if (from.tip) 0 else sh[i], coords[i, 
                                                                                                                      2]), col = colors[cw$tip.label, ][i, 1], lty = lty, 
                           lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(Y)) lines(rep(x[cw$edge[i, 2]], 
                                     2), Y[i, ], lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(range(x[cw$edge[which(cw$edge[, 
                                                                    1] == i), 2]]), Y[which(cw$edge[, 1] == i), 1], 
                                      lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(x[i], Y[which(cw$edge[, 2] == i), 2], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = c(0, 1), srt = -90, 
               cex = fsize, font = ftype)
        if (pts) 
          points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                     2], col=colors[cw$tip.label, 
                                                                                    2])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = fsize * 
                   strwidth(" ")/(par()$usr[2] - par()$usr[1]) * 
                   (par()$usr[4] - par()$usr[3]), x.lim = par()$usr[1:2], 
                 y.lim = par()$usr[3:4], direction = direction, 
                 tip.color = "black", Ntip = Ntip(cw), Nnode = cw$Nnode, 
                 edge = cw$edge, xx = x, yy = sapply(1:(Ntip(cw) + 
                                                          cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                     y = Y, z = cw$edge))
    }
    else {
      dy <- abs(diff(ylim))
      rect(xlim[1], ylim[1], xlim[1] + split[1] * (xlim[2] - 
                                                     xlim[1]), ylim[2], col = "white", border = "white")
      sh <- fsize * strwidth(paste(" ", cw$tip.label, sep = "")) + 
        0.2 * fsize * strwidth("W")
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (xlim[2] - xlim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      y <- vector(length = n + cw$Nnode)
      y[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (ylim[2] - ylim[1]) + ylim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        yy <- y[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        y[nn[i]] <- mean(range(yy))
      }
      H <- nodeHeights(cw)
      X <- xlim[1] + H
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(X[which(cw$edge[, 2] == i), 
                               2] + if (from.tip) 0 else sh[i], coords[i, 1]), 
                           c(y[i], coords[i, 2]), col = colors[cw$tip.label, 
                                                               ][i, 1], lty = lty, lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(X)) lines(X[i, ], rep(y[cw$edge[i, 
                                                       2]], 2), lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(X[which(cw$edge[, 
                                                      1] == i), 1], range(y[cw$edge[which(cw$edge[, 
                                                                                                  1] == i), 2]]), lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(X[which(cw$edge[, 2] == i), 2], y[i], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = 0.1, cex = fsize, 
               font = ftype)
        if (pts) 
          points(X[which(cw$edge[, 2] == i), 2], y[i], 
                 pch = 21, bg = colors[cw$tip.label, ][i, 
                                                       2], cex = cex.points[1])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = 0.1, 
                 x.lim = par()$usr[1:2], y.lim = par()$usr[3:4], 
                 direction = direction, tip.color = "black", Ntip = Ntip(cw), 
                 Nnode = cw$Nnode, edge = cw$edge, xx = sapply(1:(Ntip(cw) + 
                                                                    cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                               y = X, z = cw$edge), yy = y)
    }
    assign("last_plot.phylo", PP, envir = .PlotPhyloEnv)
  }
  else if (type == "direct") {
    phylomorphospace(tree, coords[, 2:1], add = TRUE, label = "horizontal", 
                     node.size = c(0, psize), lwd = lwd[2], control = list(col.node = setNames(rep(colors[2], 
                                                                                                   max(tree$edge)), 1:max(tree$edge)), col.edge = setNames(rep(colors[1], 
                                                                                                                                                               nrow(tree$edge)), tree$edge[, 2])), ftype = c("off", 
                                                                                                                                                                                                             "reg", "b", "i", "bi")[ftype + 1], fsize = fsize)
  }
}


```

```{r variables, echo = F}


# VARIABLES ----


id_col <- "wgs_id"
rnd <- 2
drugs <- c("rifampicin", "isoniazid", "ethambutol", "pyrazinamide", "streptomycin", 
             "ofloxacin", "moxifloxacin", "levofloxacin", "amikacin", "kanamycin", "capreomycin", "ciprofloxacin", "prothionamide", 
             "ethionamide", "para_aminosalicylic_acid", "cycloserine",
             "clarithromycin", "clofazimine", "bedaquiline", "linezolid", "rifabutin", "delamanid")
align <- c("l", "r", "r")
col <- "cornflowerblue"
threshold <- 10
plot_text_sz <- 0.5
main_cex <- 1.5

```

```{r paths, echo = F}


# PATHS ----


methods_path <- "../methods/"
metadata_path <- "../metadata/"
newick_path <- "../newick/"
plots_path <- "../plots/"
db_path <- "../../pipeline/db/"
dist_path <- "../dist_and_pca/"
beast_results_path <- "../beast_results/"

```

```{r files, echo = F}


# FILES ----


# Metadata
metadata_file <- paste0(metadata_path, "pakistan_metadata.csv")
historical_metadata_file <- paste0(metadata_path, "historical_metadata.csv") # http://www.pasteur-guadeloupe.fr/
# Database data
lineage_conversion_file <- paste0(db_path, "lineage_conversions.txt")
dr_genes_file <- paste0(db_path, "tbdb.bed")
# Distance
dist_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist")
dist_id_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist.id")
# Trees
tree_all_samps_newick_file <- paste0(newick_path, "PAKISTAN_ALL.filt.val.gt.g.snps.fa.treefile")
# Beast
beauti_params_file <- paste0(methods_path, "beauti_parameters.csv")
mcc_tree_file <- paste0(beast_results_path, "PAKISTAN_ALL.mcc.tree")
beast_log_file <- paste0(beast_results_path, "PAKISTAN_ALL.dated.log")
beast_clusters_file <- paste0(metadata_path, "PAKISTAN_ALL.clusters.csv")
# Drug resistance
other_variants_file <- paste0(metadata_path, "PAKISTAN_ALL.other_variants.txt")
# Images
tree_all_samps_file <- paste0(plots_path, "PAKISTAN_ALL.tree.png")
beast_clusters_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.beast_clusters.pdf")
dr_trees_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.dr_trees.pdf")
# Map
pakistan_sp_file <- paste0(metadata_path, "pakistan_sp.rds")
pakistan_lat_long_file <- paste0(metadata_path, "pakistan_lat_long.csv")
# Other
methods_file <- paste0(methods_path, "pakistan_methods.tsv")

```

```{r read_in_data, echo = F, warning=F}


# READ IN DATA ----


# Metadata
metadata <- read.csv(metadata_file)
historical_metadata <- read.csv(historical_metadata_file)
# Database data
lineage_conversions <- read.delim(lineage_conversion_file)
dr_genes <- read.delim(dr_genes_file, header = F)
# Dist
dist <- read.delim(dist_file, header = F)
dist_id <- read.delim(dist_id_file, header = F)
# Trees
tree_all_samps <- read.newick(tree_all_samps_newick_file)
# Beast
beauti_params <- read.csv(beauti_params_file)
mcc_tree_ape <- ape::read.nexus(mcc_tree_file)
mcc_tree <- treeio::read.beast(mcc_tree_file)
beast_log <- tracerer::parse_beast_log(beast_log_file)
beast_clusters <- read.csv(beast_clusters_file, header = F, col.names = c("cluster", "id"))
# Drug resistance
other_variants <- read.delim(other_variants_file, header = T)
# Map
pakistan_sp <- readRDS(pakistan_sp_file)
pakistan_lat_long <- read.csv(pakistan_lat_long_file, header = T)
# Other
methods_table <- read.table(file = methods_file, sep = '\t', header = TRUE)

```

```{r basic-wrangling, echo = F}


# BASIC WRANGLING ----


n_samps_total <- length(metadata$wgs_id)
n_snps_total <- 37970

# Subset metadata to just those with a year
metadata_dated <- subset(metadata, !(is.na(metadata$year)))
dated_samps <- metadata_dated$wgs_id

n_dated_samps <- length(dated_samps)

first_year <- min(metadata_dated$year)
last_year <- max(metadata_dated$year)

cutoff_year <- 50

# -----

# Drugs
n_drugs_total <-ncol(dplyr::select(metadata, rifampicin_test:delamanid_test))

# How many drugs phenotypically tested?
pheno_tests <- dplyr::select(metadata, rifampicin:delamanid)
pheno_test_names <- names(pheno_tests[,apply(pheno_tests, 2, function(x) {!(all(is.na(x)))} )])
n_pheno_tests <- length(pheno_test_names)
pheno_test_names <- gsub('.$', '', paste0(pheno_test_names, ",", collapse = " "))

# ----

# Dated samps
n_dated_samps <- sum(!(is.na(metadata$year)))


```

```{r wrangle-distance, echo=F}


# DISTANCE ----

# Add row and col names to distance matrix
colnames(dist) <- dist_id[, 1]
row.names(dist) <- dist_id[, 1]
# Divide dist matrix by 2 
dist <- dist/2
# Get lower only
# lower_dist <- dist[lower.tri(dist)]
# dist_dated <- dist[dated_samps, dated_samps]

# Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
dist[upper.tri(dist, diag = T)] <- 0
lower_dist <- dist[lower.tri(dist)]

# Cluster using 'single' method.
# Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
clust <- hclust(as.dist(dist), method = "single")

# Cut tree at threshold to find samples within threshold
clusters <- sort(cutree(clust, h = threshold))

# Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# Gets samples below the threshold
clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
n_clusters_cut_tree <- length(unique(clusters))

# Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
dist_thresh <- as.dist(dist[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.
dist_thresh <- dist_thresh+1 # Add 1 because 1/x later.


```

```{r wrangle-lineages, echo=F}


# LINEAGES ----


lin_tab <- reshape2::dcast(metadata, main_lineage ~ "N", value.var = id_col, fun.aggregate = length)
names(lin_tab) <- c("Lineages", names(lin_tab)[length(names(lin_tab))])
lin_tab$pc <- round((lin_tab$N/sum(lin_tab$N)) * 100, rnd)


n_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "N"]
pc_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "pc"]
n_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "N"]
pc_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "pc"]
n_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "N"]
pc_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "pc"]
n_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "N"]
pc_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "pc"]


# Lineages conversions
lin_conv <- merge(metadata[c("main_lineage", "sub_lineage")], lineage_conversions, 
                  by.x = "sub_lineage", by.y = "mtbc_lineage", 
                  all.x = T, sort = F)
lin_conv_tab <- reshape2::dcast(lin_conv, sub_lineage + lsp_lineage + spoligotype_family + rd_number ~ "N",
                                value.var = "sub_lineage", fun.aggregate = length)
lin_conv_tab$pc <- (lin_conv_tab$N / sum(lin_conv_tab$N)) * 100
names(lin_conv_tab) <- c("Lineage", "LSP lineage", "Spoligotype family", "Region of difference no.", "N", "%")
lin_conv_tab <- lin_conv_tab[order(lin_conv_tab$N, decreasing = T),]
row.names(lin_conv_tab) <- NULL


```

```{r wrangle-years, echo=F}


# YEARS ----

metadata$year_round <- round(as.numeric(metadata$year, 1))

year_tab <- reshape2::dcast(metadata, year_round ~ "N", value.var = id_col, fun.aggregate = length)
year_tab$pc <- round((year_tab$N/sum(year_tab$N)) * 100, rnd)

```

```{r wrangle-location, echo=F}


# LOCATION ----

metadata$location <- ifelse(metadata$location == "", NA, metadata$location)

location_tab <- reshape2::dcast(metadata, location ~ "N", value.var = id_col, fun.aggregate = length)
location_tab$pc <- round((location_tab$N/sum(location_tab$N)) * 100, rnd)

location_tab <- location_tab[order(location_tab$N, decreasing =T),]

```

```{r wrangle-map, echo = F, message = F, warning = F}

# Not sure what this does
pakistan_sp@data$name <- pakistan_sp@data$NAME_1
# Read in tree again (use ape because read.tree is presumably different to read.newick)
map_tree <- ape::read.tree(tree_all_samps_newick_file)
# Merge lat long data with metadata
metadata <- merge(metadata, pakistan_lat_long, 
                  by = "location", 
                  all.x = T, 
                  sort = F)
# Sort
locations <- metadata[match(map_tree$tip.label, metadata$wgs_id), ]
# Make df of just lat long, sort (not sure the sort is needed), and add rownames
lat_long <- data.frame(lat = locations$lat, long = locations$long)
lat_long <- lat_long[match(map_tree$tip.label, locations$wgs_id), ]
rownames(lat_long) <- map_tree$tip.label
# Colours
regions_uniq <- unique(locations$location)
regions_cols <- rainbow(length(regions_uniq))
map_cols <- matrix(rep(regions_cols[match(locations$location, regions_uniq)], 2),
               nrow(locations), 2, byrow=F)
rownames(map_cols) <- locations$wgs_id

# Subset to complete cases
lat_long <- lat_long[complete.cases(lat_long), ]
tips <- map_tree$tip.label
map_tree <- keep.tip(map_tree, tips[tips %in% row.names(lat_long)])
names(regions_cols) <- regions_uniq
regions_cols <- regions_cols[!(is.na(names(regions_cols)))]
regions_uniq <- regions_uniq[complete.cases(regions_uniq)]

# Do map
obj <- phylo.to.map(map_tree, lat_long, plot = FALSE, database = pakistan_sp, fill=T)


```


```{r wrangle-tree, echo=F}


# TREE ----


tree_all_samps <- midpoint.root(tree_all_samps)

```

```{r wrangle-beast, echo=F}


# BEAST ----


names(beauti_params) <- c("Beauti tab", "Selection", "Parameter values [min, max]")

# Beast clusters
n_beast_clusters <- length(unique(beast_clusters$cluster))
n_beast_cluster_samps <- nrow(beast_clusters)

```

```{r wrangle-DR-basic, echo=F}


# DR ----


# Specific drugs - phenotypic tests (DST)
drugs_data <- apply(metadata[drugs], 2, as.numeric)
dr_tab <- as.data.frame(t(t(apply(drugs_data[, drugs], 2, sum, na.rm = T))))
dr_tab$drug_resistance <- row.names(dr_tab)
names(dr_tab) <- c("N", "drug")
dr_tab <- dr_tab[c("drug", "N")]
row.names(dr_tab) <- NULL
dr_tab$pc <- round((dr_tab$N/n_samps_total) * 100, rnd)

# Genotypic DR - TBprofiler
tbp_drug_tests <- grep("_tbp", names(metadata), value = T)
n_tbp_drug_tests <- length(tbp_drug_tests)
tbp_data <- ifelse(metadata[tbp_drug_tests] == "-", 0, 1)
tbp_data <- as.data.frame(t(t(apply(tbp_data, 2, sum, na.rm = T))))
tbp_data$drug <- row.names(tbp_data)
row.names(tbp_data) <- NULL
tbp_data <- tbp_data[, c(2, 1)]
names(tbp_data)[2] <- "N"
tbp_data$pc <- round((tbp_data$N/n_samps_total) * 100, rnd)
tbp_data$drug <- gsub("_tbp", "", tbp_data$drug)

# Put DST and TBprofiler results together
dr_tab <- merge(dr_tab, tbp_data, by = "drug", all = T, sort = F)
names(dr_tab) <- c("Drug", "N DST resistant", "% DST resistant", "N genotypic resistant", "% genotypic resistant")


# DR status
# Desired order of DR cols
dr_vals <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other") 
dr_status_tab <- reshape2::dcast(metadata, dr_status ~ "N", value.var = id_col, fun.aggregate = length)
dr_status_tab <- dr_status_tab[match(dr_vals, dr_status_tab$dr_status), ]
names(dr_status_tab) <- c("Status", names(dr_status_tab)[length(names(dr_status_tab))])
dr_status_tab$pc <- round((dr_status_tab$N/sum(dr_status_tab$N)) *100, rnd)
row.names(dr_status_tab) <- NULL

n_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "N"]
pc_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "pc"]
n_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "N"]
pc_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "pc"]
n_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "N"]
pc_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "pc"]

# DR status by lineage
dr_lin_tab <- reshape2::dcast(metadata,  dr_status ~ main_lineage, value.var = id_col, fun.aggregate = length)
dr_lin_tab$dr_status <- factor(dr_lin_tab$dr_status, levels = dr_vals)
dr_lin_tab <- dr_lin_tab[order(dr_lin_tab$dr_status), ]
names(dr_lin_tab) <- c("DR status", paste0("L", sort(unique(metadata$main_lineage))))
dr_lin_tab <- to_table(dr_lin_tab, pc_dir = "all")
row.names(dr_lin_tab) <- NULL


```

```{r wrangle-discrepancies-other-variants, echo=F}


# DISCREPANCIES ----


FN <- "pheno_res; geno_sens"
FP <- "pheno_sens; geno_res"
discrepancy_data <- metadata[, grep("_test", names(metadata), value = T)]



# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!


FN_res <- apply(discrepancy_data, 2, function(x){sum(x == FN, na.rm = T)})
FP_res <- apply(discrepancy_data, 2, function(x){sum(x == FP, na.rm = T)})


# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!
# REMOVE na.rm = T !!!!!!!!!



# dd <- metadata[metadata$wgs_id == "ERR3335799", grep("_test", names(metadata), value = T)]
# apply(dd, 2, function(x){sum(x == FN)})



discrepancy_data$wgs_id <- metadata$wgs_id # Add ids in for the other variants stuff
# REMOVE na.rm = T !!!!!!!!!
n_FN_samps <- sum(FN_res)
n_FP_samps <- sum(FP_res)
FN_drugs_split <- names(FN_res[FN_res > 0])
FP_drugs_split <- names(FP_res[FP_res > 0])
n_FN_drugs <- length(FN_drugs_split)
n_FP_drugs <- length(FP_drugs_split)
FN_drugs <- gsub("_test", "", paste0(FN_drugs_split, collapse = ", ") )
FP_drugs <- gsub("_test", "", paste0(FP_drugs_split, collapse = ", ") )

# Drug resistance genes lookup table ----

# Convert to one row per drug
names(dr_genes) <- c("chr", "start", "end", "locus", "gene", "drugs")
dr_genes$drugs <- gsub("para-aminosalicylic_acid", "para_aminosalicylic_acid", dr_genes$drugs)
dr_genes <- data.frame(dr_genes %>% 
                         mutate(drugs = strsplit(as.character(drugs), ",")) %>% 
                         unnest(drugs))

dr_genes <- dr_genes[order(dr_genes$drugs), ]


# Other variants ---- 

# # Join id_year col onto other_variants data
# other_variants <- merge(other_variants, metadata[, c("wgs_id")], 
#                         by = "wgs_id", sort = F)


# FN

FN_results <- data.frame()
for(i in seq(FN_drugs_split)){
  # Get drug and remove "_test"
  drug <- FN_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FN_samps <- discrepancy_data[discrepancy_data[drug] == FN, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FN_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FN_results <- rbind(ov_sub, FN_results)
}

# other_variants[other_variants[,"id_year"] == "ERR2510452_NA", ]

# Neaten table 
FN_results_table <- unique(FN_results[, !(names(FN_results) %in% c("locus_tag_drugs", "wgs_id", "id_year"))])
FN_results_table <- FN_results_table[order(FN_results_table$drug, FN_results_table$gene, FN_results_table$genome_pos), ]
row.names(FN_results_table) <- NULL

# FN_results_table[, !(names(FN_results_table) %in% c(""))]

# n_pza_FN_samps <- length(unique(FN_results[FN_results$drug == "pyrazinamide"]$wgs_id))
# pza_FN_mutations <- unique(FN_results[FN_results$drug == "pyrazinamide"]$change)
# pza_FN_mutations_print <- paste0(pza_FN_mutations, collapse = ", ")
# n_pza_FN_mutations <- length(pza_FN_mutations)

# FP 

FP_results <- data.frame()
for(i in seq(FP_drugs_split)){
  # Get drug and remove "_test"
  drug <- FP_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FP_samps <- discrepancy_data[discrepancy_data[drug] == FP, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FP_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FP_results <- rbind(ov_sub, FP_results)
}

# Neaten table
FP_results_table <- unique(FP_results[, !(names(FP_results) %in% c("locus_tag_drugs", "wgs_id", "id_year"))])
FP_results_table <- FP_results_table[order(FP_results_table$drug, FP_results_table$gene, FP_results_table$genome_pos), ]
row.names(FP_results_table) <- NULL

```

```{r wrangle-loc-lin-dr-dates, echo = F}


# TABLE 1 ----


# "Table 1 – locations, lineages, drug resistance, dates of collection…"


table_1 <- data.frame()
table_1 <- rbind(table_1, 
                 setNames(lin_tab, names(table_1)), 
                 setNames(dr_status_tab, names(table_1)), 
                 setNames(dr_tab[, c("Drug", "N genotypic resistant", "% genotypic resistant")], names(table_1)), 
                 setNames(year_tab, names(table_1)), 
                 setNames(location_tab, names(table_1)))

names(table_1) <- c("Characteristic", "N", "%")

table_1$Category <- c(rep("Lineage", nrow(lin_tab)), 
                      rep("DR status", nrow(dr_status_tab)), 
                      rep("Predicted drug resistance", nrow(dr_tab)), 
                      rep("Collection year", nrow(year_tab)),
                      rep("Region", nrow(location_tab)))

table_1 <- table_1[, c( "Category", "Characteristic", "N", "%")]

# table_1 <- table_1[complete.cases(table_1), ]

row.names(table_1) <- NULL



```

```{r ggtree-setup, echo = F}


# GGTREE SETUP ----


# Prep data for heatmaps (strips)

legend_spec <- theme(legend.title = element_text(size = 7),
                     legend.text = element_text(size = 5),
                     legend.key.size = unit(0.3, "cm"))

# Add id/year hybrid col
metadata$id_year <- paste0(metadata$wgs_id, "_", metadata$year)
rownames(metadata) <- metadata$id_year
# heatmap_data <- metadata[metadata$id_year %in% mcc_tree_ape$tip.label,
#                          c("main_lineage", "dr_status"), drop = F]
# Subset metadata
lin_data <- metadata[, "main_lineage", drop = F]
dr_status_data <- metadata[, "dr_status", drop = F]
loc_data <- metadata[, "location", drop = F]
dr_data <- dplyr::select(metadata, rifampicin:delamanid)
dr_tbp_data <- dplyr::select(metadata, rifampicin_tbp:delamanid_tbp)
drug_discrepancy_data <- dplyr::select(metadata, rifampicin_test:delamanid_test)

# Clean location data
loc_data[loc_data == ""] <- NA

# Clean dr_tbp_data
dr_tbp_data[dr_tbp_data != "-"] <- 1
dr_tbp_data[dr_tbp_data == "-"] <- 0

# Convert lin and DR data to factors
dr_data <- data.frame(apply(dr_data, 2, as.factor))
dr_tbp_data <- data.frame(apply(dr_tbp_data, 2, as.factor))
lin_data <- data.frame(apply(lin_data, 2, as.factor))
# drug_discrepancy_data <- data.frame(apply(drug_discrepancy_data, 2, as.factor))

# Change col names
colnames(dr_status_data) <- "DR status"
colnames(lin_data) <- "Lineage"
colnames(loc_data) <- "Location"

# Define cols for each dataset
alpha <- 0.9
lin_colours <- rainbow(length(unique(metadata$main_lineage)), alpha = alpha)
dr_status_colours <- scales::alpha(gplots::col2hex(c("green1", "yellow2", "orange1", "red1", "black", "grey")), alpha = alpha)


n <- length(unique(loc_data$Location))
qual_col_pals <- brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector <- unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
set.seed(2)
loc_cols <- sample(col_vector, n)
names(loc_cols) <- unique(loc_data$Location)
loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

# loc_cols <- randomcoloR::distinctColorPalette(length(unique(loc_data$Location)))
# names(loc_cols) <- unique(loc_data$Location)
# loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
# loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

drug_discrepancy_vals <- sort(unique(as.vector(as.matrix(drug_discrepancy_data))))
drug_discrepancy_cols <- brewer.pal(length(drug_discrepancy_vals), "Paired")

# Add names (unique vals for each dataset) to dataframes. Don't need to do this for the binary data (DR individual status)
names(lin_colours) <- c(sort(unique(metadata$main_lineage)))
names(dr_status_colours) <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other")
names(drug_discrepancy_cols) <- drug_discrepancy_vals

```

| | |
| ----------- | ----------- |
|Gary Napier^1^,* | gary.napier@lshtm.ac.uk |
|Anwar Sheed Khan^2^,^3^,*	|	anwar786kp@hotmail.com |
|Muhammad Tahir Khan^4^ |	muhammad.tahir8@imbb.uol.edu.pk |
|Sajid Ali^2^ | sajidjan@live.com |
|Muhammad Qasim^2^ | qasim@kust.edu.pk |

XXXXX Aga Khan group XXXX	

| | |
| ----------- | ----------- |
|Susana Campino^1^ | susana.campino@lshtm.ac.uk |
|Sajjad Ahmad^5^ | sajjadahmad793@yahoo.com |
|Hazir Rahman^6^ | hazirrahman@hotmail.com |
|Taj Ali Khan^5^,** | tajalikhan.ibms@kmu.edu.pk |
|Jody E. Phelan^1^,** | jody.phelan@lshtm.ac.uk |
|Taane G. Clark^1^,^7^,** | taane.clark@lshtm.ac.uk |

XXX to be confirmed XXX

^1^ Faculty of Infectious & Tropical Diseases, London School of Hygiene & Tropical Medicine, London, UK \
^2^ Department of Microbiology, Kohat University of Science and Technology, Kohat, Pakistan; \
^3^ Provincial Tuberculosis Reference, Laboratory Hayatabad Medical Complex, Peshawar, Pakistan; \
^4^ Institute of Molecular Biology and Biotechnology (IMBB), The University of Lahore. KM, Defense Road, Lahore 58810, Pakistan \
^5^ Institute of Basic medical Science Khyber Medical University, Peshawar KP, Pakistan \
^6^ Department of Microbiology, Abdul Wali Khan University, Mardan, Pakistan \
^7^ Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, London, UK \


\* Joint authors \
\*\* Joint Correspondence: \
Prof. Taane G. Clark, London School of Hygiene & Tropical Medicine, UK; taane.clark@lshtm.ac.uk
Dr. Jody Phelan, London School of Hygiene & Tropical Medicine, UK; jody.phelan@lshtm.ac.uk
Dr. Taj ali Khan, Institute of Basic medical Science Khyber Medical University Peshawar KP Pakistan; tajalikhan.ibms@kmu.edu.pk




## ABSTRACT



## INTRODUCTION


Tuberculosis disease (TB), caused by bacteria in the Mycobacterium tuberculosis (Mtb) complex, is a major global public health problem. Pakistan is a high-burden TB country, being one of eight countries accounting for two-thirds of the global total TB instance (5.7%). In 2019 it had a  total TB incidence of 570,000 and 43,900 deaths [@WHO_2020]. Furthermore, HIV prevalence in the country is increasing (0.1 prevalence 2019), which compounds the problem of TB infections and treatment [@UNAIDS_2020] (5,100 cases and 1,900 HIV-positive mortality cases in 2019). There is also a high burden for multidrug-resistance (MDR-TB, resistance to isoniazid and rifampicin treatments), with 25,000 cases in the latest WHO estimates. 

<!--
**Estimates of TB burden, 2019** 

| | Number | (Rate per 100,000 population) |
|-----------|-----------|-----------|
| Total TB incidence | 570,000 (404,000-764,000)	| 263 (187-353) |
| HIV-positive TB incidence |	5,100 (3,400-7,200)	| 2.4 (1.6-3.3) |
| MDR/RR-TB incidence | 25,000 (16,000-36,000) | 12 (7.3-17) |
| HIV-negative TB mortality |	42,000 (34,000-51,000) | 19 (16-24) | 
| HIV-positive TB mortality	| 1,900 (1,300-2,800)	| 0.9 (0.58-1.3) |

**Estimated proportion of TB cases with MDR/RR-TB, 2019**

|  |  |
|-----------|-----------|
| New cases |	4.2% (3.2-5.3) |
| Previously treated cases |	7.3% (6.8-7.8) |
-->

Whole genome sequencing is revolutionizing our understanding of drug resistance and clinical management, as well as transmission patterns, thereby can assist disease control. Within such a context, it is crucial to monitor transmission patterns and ensure that patients are being treated with optimal drug regimens. Here, we analyse `r n_samps_total` whole genome sequences (WGS) of Pakistan *Mycobacterium tuberculosis* (*Mtb*) samples dating from `r first_year` to `r last_year`, using `r fmt(n_snps_total)` SNPs to infer a timed phylogenetic tree and to predict resistance to `r n_drugs_total` drugs. While our data included phenotypic tests of resistance for `r n_pheno_tests` drugs (`r pheno_test_names`), we also applied genotypic tests of drug resistance using TBprofiler [@Coll2015] to predict drug resistance from a database of ~34,000 WGS samples. 


## RESULTS

### Clinical isolates and phylogeny

A total of `r n_samps_total` *M. tuberculosis* WGS isolates from Pakistan were downloaded from the European Nucleotide Archive (ENA). The samples were cultured, whole-genome sequenced, and drug susceptibility testing (DST) was applied for `r n_pheno_tests` drugs. Combining the results of the DST and the genotypic prediction tests (see **Methods**), `r n_sens` (`r pc_sens`%) samples were pan-sensitive, `r n_mdr` (`r pc_mdr`%) classed as MDR-TB (resistant to both rifampicin and isoniazid), and `r n_xdr` (`r pc_xdr`%) were XDR (resistant to isoniazid and rifampicin, plus any fluoroquinolone and at least one of three injectable second-line drugs). See **Table \@ref(tab:drTableLin)** for Pre-MDR, Pre-XDR figures and drug resistance categories by lineage. 

Upon mapping the sequences, high average coverage was observed across the samples: XXX. A total of `r fmt(n_snps_total)` SNPs were identified, with XXX% found in single isolates. 

Historically, *Mtb* samples from Pakistan belong predominantly to the CAS1-Delhi spoligotype family [@Demay2012] (see **Figure \@ref(fig:historical)**), which belongs to Lineage 3 [@Napier2020]. In our samples, Lineage 3 comprises `r lin_tab[lin_tab["Lineages"] == 3, "pc"]`% of the total samples, followed by Lineage 4 (n=`r n_lin_4`, `r pc_lin_4`%), Lineage 2 (n=`r n_lin_2`, `r pc_lin_2`%) and Lineage 1 (n=`r n_lin_1`, `r pc_lin_1`%) (see **Table \@ref(tab:lintable)** for a breakdown of samples by lineage and sublineage and see **Figure \@ref(fig:treeAllSamps)** for a full phylogenetic tree). 

### Evidence of transmission

Median (range) pairwise SNP distances was `r round(median(lower_dist), rnd)` (`r min(lower_dist)`-`r max(lower_dist)`) for all `r n_samps_total` samples (**Figure \@ref(fig:boxdistance)**). For all dated samples (n=`r n_dated_samps`), the median SNP distance was `r round(median(lower_dist), rnd)` (**Figure \@ref(fig:boxdistance)**). With a threshold of `r threshold` SNPs for the dated samples, `r n_clusters_cut_tree` clusters formed, where a cluster contains at least two samples (**Figure \@ref(fig:clusterstreedated)**). **Figure \@ref(fig:distanceqgraph)** shows a graph of SNP distance connections among all dated samples within the `r threshold`-threshold SNP distance.  

Date of collection was recorded between the years `r first_year` and `r last_year` (`r last_year - first_year` years; **Figure \@ref(fig:dates)**) for `r n_dated_samps` samples, which represent probable closely-related, if not potiential transmission cases. A dated phylogenetic tree was constructed with these samples (**Figures \@ref(fig:beasttrees)**), and when cut at `r cutoff_year` years before the last sample date, `r n_beast_clusters` clusters (n=`r n_beast_cluster_samps`) were inferred (**Figures \@ref(fig:beasttreeszoom)**). 

### Drug susceptibility discrepancies

We identified DSTs that disagreed with the genotypic drug resistance predictions for all samples (n=`r n_samps_total`). These discrepancies were classified into two kinds (relevant to novel mutations) - where the phenotypic test showed resistance and the genotypic test predicted sensitivity ("false negative" (FN)), and where the phenotypic test result was sensitive but the genotypic test predicted resistance ("false positive" (FP)). Within the clusters defined above, `r n_FN_samps` samples were FN for `r n_FN_drugs` (`r FN_drugs`) and `r n_FP_samps` samples were FP for `r n_FN_drugs` (`r FP_drugs`) (**Figure \@ref(fig:beasttreeszoom)(C)**).

### Mutations underlying drug-resistance

For FN samples (n=`r n_FN_samps`), **Table \@ref(tab:FNresultstable)** shows variants found in drug resistance-associated genes for `r n_FN_drugs` (`r FN_drugs`), that were previously unknown to be associated with each respective drug, potentially explaining discrepancies between DST and genotypic predictions. 

## DISCUSSION


## METHODS

<!--
```{r methods, echo=FALSE, out.width = "1500px"}

kable(methods_table)

```
-->

### Sequence data and processing

Sequences were downloaded from the European Nucleotide Archive (ENA www.ebi.ac.uk/ena/) and quality inspection of reads assessed in fastQC (version 0.11.9, www.bioinformatics.babraham.ac.uk/projects/fastqc/). Reads were trimmed to remove low-quality sequences in Trimmomatic v0.39 [@Bolger2014] and aligned to the H37Rv reference genome (AL123456) with BWA mem v0.7.17 [@Li2013], [@Cole1998]. 

Joint SNP calling was processed in gatk GenotypeGVCFs v4.1.3.0 [@Depristo2011]. SNP filtering excluded indels, heterozygous SNPs, monomorphic SNPs and non-unique regions of the genome (e.g. PE/PPE genes), which was conducted in bcftools v1.9 [@Li2009]. 

A multi-FASTA format file was created from the filtered SNP file and H37Rv reference fasta using bedtools makewindows v2.28.0 [@Quinlan2010] which in turn was used to construct a phylogenetic tree with IQ-TREE v1.6.12. Here, a general time reversible model with rate heterogeneity set to a discrete Gamma model and an ascertainment bias correction were used (parameters -m GTR+G+ASC), with 1000 bootstrap samples used to measure branch quality and robustness. [@Nguyen2015] [@Hoang2018] [@Tavare1986] [@Lewis2001] [@Yang1994].

Pairwise distance matrices were calculated in Plink v1.90b4 [@Purcell2007]. Drug resistance status, drug resistance-associated mutations, other mutations, and lineages were predicted *in silico* using TB-Profiler v2.4 [@Phelan2019] [@Coll2015] [@Napier2020]. In categorising samples as *Susceptible*, *Pre-MDR*, *MDR*, *Pre-XDR*, *XDR*, or *other*, the TB-Profiler predictions were used in place of missing or contradictory DST data. 

BEAST v2.6.3 [@Bouckaert2019] was used to infer timed phylogenetic trees (see **Table \@ref(tab:beautiparams)** for parameters and settings). From the high ESS values (**Table \@ref(tab:beastlogtable)**) and the non-directional trace plots in (**Figure \@ref(fig:beastlogplots)**), effective sample size seems satisfactory and parameters have converged.

***

### Tables

```{r table-1, echo=FALSE, out.width = "2000px"}

knitr::kable(table_1, row.names = NA, rownames.print = F, caption = sprintf("*Mycobacterium tuberculosis* samples (N = %s)", n_samps_total))

```
***
```{r drTableLin, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_lin_tab, row.names = NA, rownames.print = F, caption = "Drug resistance categories by lineage. See *Methods* section for criteria of categories.")

```
***
```{r drtable, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_tab, caption = "Numbers and percentages of drug-resistant samples accourding to DST and genotypic predictions (TBprofiler)")

```
***
```{r lintable, echo=FALSE, out.width = "2000px"}

# knitr::kable(lin_tab, align = align)
# cap <- "Table of main sublineages as proposed by Comas et al (2010) [@Comas2010] and Stucki et al (2016) [@Stucki2016] and predicted by Napier (2020) [@Napier2020], and their equivalents in 'Large Sequence Polymorphism' lineages[@GagneuxDeRiemer2006] and spoligotype families[@Demay2012]."
cap <- "Strain-types"
knitr::kable(lin_conv_tab, caption = cap)

```
***
```{r FNresultstable, echo=FALSE, out.width = "2500px"}

knitr::kable(FN_results_table, caption = sprintf("Table of variants previously unknown to be associated with drug resistance (for each respective drug) among 'FN' drug susceptibility test samples (n=%s)", n_FN_samps))

```
***
```{r beautiparams, echo=FALSE, out.width = "2000px"}

knitr::kable(beauti_params, caption = "Settings in Beauti for BEAST analysis. Parameters & priors are based on Xu (2020) [@Xu2020]")

```
***
```{r beastlogtable, echo=FALSE, out.width = "1500px"}

# Results of beast log

# Remove the burn-in
beast_log <- tracerer::remove_burn_ins(
  beast_log,
  burn_in_fraction = 0.1
)

# Calculates the effective sample sizes of all parameter estimates
esses <- t(tracerer::calc_esses(beast_log, sample_interval = 1000))

# Get means
means <- apply(beast_log, 2, mean)
means <- means[!(names(means) %in% "Sample")]

# Combine
log_table <- cbind(means, esses)
colnames(log_table) <- c("Mean", "ESS")
log_table <- round(log_table, 2)

knitr::kable(log_table, caption = "Mean and effective sample size (ESS) outputs from BEAST for tree parameter posteriors.")

```
***

### Figures

```{r historical, fig.cap = sprintf("Number of samples by spoligotype family \n in historical Mtb data from Pakistan [@Demay2012], n = %s", n_samps_historical) , echo=FALSE, out.width = "2000px"} 

n_samps_historical <- length(historical_metadata$IsoNumber)

barplot(table(historical_metadata$Clade), las=2, main = "", col = col, cex.axis = 0.5, cex.names=0.75)

```
 
***
<!--
```{r treeAllSamps, echo=FALSE, out.width = "2000px", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total)) }

cap <- sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))

knitr::include_graphics(tree_all_samps_file)

```
-->
***

```{r ggtree-all-samps, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))}

# Tree setup
line_sz <- 0.25
n <- length(tree_all_samps$tip.label)
width <- 0.1
angle <- 45

# Remove years from lineage data
lin_data_no_year <- lin_data
row.names(lin_data_no_year) <- unlist(lapply(strsplit(row.names(lin_data_no_year), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from DR data 
row.names(dr_status_data) <- unlist(lapply(strsplit(row.names(dr_status_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from location data
row.names(loc_data) <- unlist(lapply(strsplit(row.names(loc_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))


ggtree_all_samps <- ggtree(tree_all_samps, size = line_sz, layout="circular")

# Add lin data
lin_hm <- gheatmap(ggtree_all_samps, lin_data_no_year,
         width = width,
         # offset = offset,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle, 
         colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) ) +
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = width * 0.025,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR status")+
  legend_spec

dr_status_hm

# dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()
# 
# gheatmap(dr_status_hm, loc_data,
#                    width = width,
#                    offset = width * (0.025*2),
#                    color = NULL,
#                    colnames_position = "top",
#                    colnames_angle = angle, colnames_offset_y = 1,
#                    hjust = 0,
#                    font.size = 2) +
#   scale_fill_manual(values = loc_cols, breaks = names(loc_cols), na.value="white")+
#   labs(fill = "Location")+
#   legend_spec


```

***

```{r map, echo=FALSE, out.width = "2000px", fig.cap=sprintf("Locations of samples; n = %s", length(obj$tree$tip.label))}

plot(obj, lty = 1, fsize = 0.01, direction = "rightwards", colors = map_cols, pch=20)
legend("bottomright", legend = regions_uniq, fill = regions_cols)

```

***

```{r dates, echo=FALSE, out.width = "2000px", fig.cap=sprintf("Histogram of sample collection year; n = %s", n_dated_samps)}

year <- round(as.numeric(metadata$year[!is.na(metadata$year)], 1))
years <- sort(unique(year))
breaks <- (min(year)-0.5):(max(year)+0.5)
yr_hist <- hist(year, freq = T, xaxt="n", xlab= "year",
                breaks = breaks, col = col, main = "")
axis(side = 1, at = yr_hist$mids, labels = years)

```

***

```{r boxdistance, echo=FALSE, fig.show="hold", out.width="50%", fig.cap = sprintf("Boxplot of pairwise SNP distances (excluding DR sites), all samples (left; n = %s), samples within %s SNP distance (right; n = %s).", nrow(dist), threshold, nrow(as.matrix(dist_thresh)))}

# Summary of distances for all samples
# lower_dist <- dist[lower.tri(dist)]
boxplot(lower_dist, 
    col = col, 
    main = sprintf("mean = %s; median = %s", round(mean(lower_dist), rnd), round(median(lower_dist), rnd) ), 
    cex.main = main_cex, 
    ylab="SNP distance")

# Summary of dists for threshold (clustered) samples
# dist_dated <- dist[dated_samps, dated_samps]
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
boxplot(dist_thresh, col = col,
        main = sprintf("mean = %s; median = %s", round(mean(dist_thresh), rnd), round(median(dist_thresh), rnd) ),
        cex.main = main_cex,
        ylab="SNP distance")

```

***

```{r clusterstree, echo = F, out.width = "2000px", fig.cap = sprintf("Single linkage tree of SNP distances, dated samples. Line shown at a SNP distance of %s; n = %s; n clusters = %s", threshold, nrow(dist), n_clusters_cut_tree)}

# # dist_dated <- as.dist(dist_dated)
# 
# # Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# 
# # Cluster using 'single' method.
# # Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
plot(clust, labels = F, xlab = "", main = "")
abline(a = threshold, b = 0)
# # Cut tree at threshold to find samples within threshold
# clusters <- sort(cutree(clust, h = threshold))
# 
# # Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# # Gets samples below the threshold
# clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
# 
# n_clusters_cut_tree <- length(unique(clusters))
# 
# # Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.

```

***

```{r distanceqgraph, echo=FALSE, out.width = "2000px", fig.cap = sprintf("Graph of samples. Connections among samples with <= %s SNP distance; n = %s. Thicker lines indicate smaller SNP distance.", threshold, length(attributes(dist_thresh)$Labels)), fig.show="hold"}

# qgraph::qgraph(1/dist_dated_thresh, layout='spring', vsize=5)

# Subset
# lin_data_qgraph <- lin_data[row.names(lin_data) %in% attributes(dist_dated_thresh)$Labels, "Lineage", drop = F]
lin_data_qgraph <- lin_data_no_year[row.names(lin_data_no_year) %in% attributes(dist_thresh)$Labels, "Lineage", drop = F]
# Add sample names to df
lin_data_qgraph$samp <- row.names(lin_data_qgraph)
# Convert to DM for easy access to row and col names
# dist_mat <- as.matrix(dist_dated_thresh)
dist_mat <- as.matrix(dist_thresh)
# Get the row index for each samp in the DM
dist_samp_ind <- data.frame(samp = row.names(dist_mat), row = seq(row.names(dist_mat)))
# Merge with lin data
lin_data_qgraph <- merge(dist_samp_ind, lin_data_qgraph,
                         by = "samp", 
                         sort = F)
# Split by lin
lin_data_split <- split(lin_data_qgraph, lin_data_qgraph$Lineage)
# Loop over split df and replace lists with row nums
for(i in seq(lin_data_split)){
  lin_data_split[[i]] <- lin_data_split[[i]]$row
}

# Edge thickness
cut_val <- 0.5
# Node size
vsize_val <- 2

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = lin_data_split, 
               legend = TRUE, 
               color = lin_colours)


# Same for DR data
dr_status_data_qgraph <- dr_status_data[row.names(dr_status_data) %in% attributes(dist_thresh)$Labels, "DR status", drop = F]
dr_status_data_qgraph$samp <- row.names(dr_status_data_qgraph)
dr_data_qgraph <- merge(dist_samp_ind, dr_status_data_qgraph,
                         by = "samp", 
                         sort = F)
dr_data_split <- split(dr_data_qgraph, dr_data_qgraph["DR status"])
# Re-arrange order to match col vector
dr_data_split <- dr_data_split[names(dr_status_colours)]

for(i in seq(dr_data_split)){
  dr_data_split[[i]] <- dr_data_split[[i]]$row
}

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = dr_data_split, 
               legend = TRUE, 
               color = dr_status_colours)

# Location
loc_data_qgraph <- loc_data[row.names(loc_data) %in% attributes(dist_thresh)$Labels, "Location", drop = F]
loc_data_qgraph$samp <- row.names(loc_data_qgraph)
loc_data_qgraph <- merge(dist_samp_ind, loc_data_qgraph,
                         by = "samp", 
                         sort = F)
# Convert NA to something else
loc_data_qgraph[is.na(loc_data_qgraph$Location), "Location"] <- "N/A"
# Do the same for col
names(loc_cols)[is.na(names(loc_cols))] <- "N/A"
loc_data_split <- split(loc_data_qgraph, loc_data_qgraph["Location"], drop = T)

# Subset so that next line does not contain NAs (does for some reason if don't match)
loc_cols_qgraph <- loc_cols[names(loc_cols) %in% names(loc_data_split)]
# Re-order split-df to same order as loc vector
loc_data_split <- loc_data_split[names(loc_cols_qgraph)]

for(i in seq(loc_data_split)){
  loc_data_split[[i]] <- loc_data_split[[i]]$row
}

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = loc_data_split, 
               legend = TRUE, 
               color = loc_cols_qgraph)

  
```

***

```{r beasttrees, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap="Timed phylogenetic trees of all dated samples (n = n_dated_samps), inferred from BEAST. A - Timed phylogenetic tree annotated with drug resistance statuses from phylogenetic tests (DST); B - The same tree annotated with drug resistance statuses from genotypic profiling (TBprofiler); C - Annotated with the discrepancies between the phenotypic and genotypic tests."}


# Get last date from tree
first_date <- mcc_tree_ape$root.edge
last_date <- as.numeric(max(unlist(lapply(strsplit(mcc_tree_ape$tip.label, "_"), function(x){x[length(x)]}))))
last_date_chr <- paste0(as.character(last_date), "-12-31")
n_samps <- length(mcc_tree_ape$tip.label)


# Tree setup
x_lim <- c(first_date-10, last_date+(last_date*0.8))
y_lim <- c(-5, n_samps + (n_samps * 0.1))
v_line_col <- "red"
x_labs_full <- seq(first_date, last_date, by = 100)
x_labs_zoom <- seq(last_date-50, last_date, by = 1)
offset <- 50
width <- 0.05
angle <- 45
line_sz <- 0.2

# Draw basic tree
gg_mcmc_tree <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) +
  theme_tree2() +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  geom_range("length_0.95_HPD", color='red', size=2, alpha=.5) +
  geom_text2(aes(label=round(as.numeric(posterior), 2),
                 subset=as.numeric(posterior)> 0.9,
                 x=branch), vjust=0) +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)+
  theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree, lin_data,
         width = width,
         offset = offset, color = NULL,
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = offset+100, color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR status")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

width_plus <- 0.6
font_sz <- 2

# pdf(file = dr_trees_pdf_file)
gheatmap(dr_status_hm, dr_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

# Drug resistance from TB profiler (genotypic drug resistance predictions)

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset+200,
         width = width + width_plus,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

```

***

<!--
```{r beasttreeszoom, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The same trees and annotations as Figure \\@ref(fig:beasttrees), zoomed in to the last 50 years before the last sample date. Samples which do not form a cluster (the MRCA was before 50 years or there is only one sample) have been dropped. n = %s",  n_beast_cluster_samps)}

# Zoom in to clusters

# Zoom tree setup
zoom_range <- c((last_date+1) - 50, (last_date + 1) + 65)
zoom_range_seq <- seq(zoom_range[1], (last_date+1), 2)

offset_zoom <- 0
width_zoom <- 0.0015

gg_mcmc_tree_zoom <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) %<+% metadata +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  geom_tiplab(align=T, size = 1.5, linetype=NA, hjust = -3.9)+
  theme_tree2() +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = zoom_range_seq,
                    labels = zoom_range_seq,
                    limits = zoom_range) +
  # scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)+
  geom_vline(aes(xintercept = 2020), col = "red")+
  # geom_tiplab(align = TRUE, linetype='dashed', linesize=.3, size = 2) +
  theme(axis.text.x = element_text(face = "bold", size = 6, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree_zoom, lin_data,
                   width = width_zoom,
                   offset = offset_zoom,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                         width = width_zoom,
                         offset = offset_zoom + 2.5,
                         color = NULL,
                         colnames_position = "top",
                         colnames_angle = angle, colnames_offset_y = 1,
                         hjust = 0,
                         font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR\nstatus")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()
offset_zoom_plus <- 6

gheatmap(dr_status_hm, dr_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

# dev.off()

# # Loop through clusters
# 
# clusters_split <- split(beast_clusters, beast_clusters$cluster)
# mcc_tree_tips <- mcc_tree@phylo$tip.label
# 
# # pdf(file = beast_clusters_pdf_file)
# for(i in seq(clusters_split)){
# 
#   names_to_keep <- clusters_split[[i]]$id
#   names_to_drop <- mcc_tree_tips[!(mcc_tree_tips %in% names_to_keep)]
#   clust_tree <- treeio::drop.tip(mcc_tree, names_to_drop)
# 
#   # Do tree first to get first and last date
#   last_date_clust <- as.numeric(max(unlist(lapply(strsplit(clust_tree@phylo$tip.label, "_"), function(x){x[length(x)]}))))
#   last_date_clust_chr <- paste0(as.character(last_date), "-12-31")
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2()
#   last_date_clust <- ceiling(max(gg_clust_tree$data$x))
#   first_date_clust <- floor(min(gg_clust_tree$data$x))
# 
#   n_samps <- length(clust_tree@phylo$tip.label)
#   last_date_clust_chr <- paste0(last_date_clust-1, "-12-31")
#   date_range_clust <- c(first_date_clust, last_date_clust)
#   year_span_clust <- diff(date_range_clust)
#   oom <- log10_ceiling(year_span_clust)
#   if(oom == 1){
#     by <- 1
#   }else if(oom == 10){
#     by <- 2
#   }else if(oom == 100){
#     by <- 10
#   }else{
#     by <- 100
#   }
#   zoom_range_seq_clust <- seq(first_date_clust,
#                               last_date_clust,
#                               by = by)
# 
#   post_tree_multiply <- 5
#   post_tree_span <- (year_span_clust * post_tree_multiply)
#   x_lim_clust <- c(first_date_clust - (year_span_clust*0.2), last_date_clust + post_tree_span)
#   y_lim_clust <- c(0 - floor(n_samps*0.1),  n_samps + ceiling(n_samps*0.2) )
#   # width <- width * (p$data$x %>% range(na.rm = TRUE) %>% diff)/ncol(data)
#   width_clust <- 0.035 * post_tree_multiply  # % of tree time span
#   # offset_clust <- (width_clust * year_span_clust) + ((width_clust * year_span_clust)*0.1)
#   offset_clust <- (width_clust * year_span_clust)
# 
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2() +
#     coord_cartesian(ylim = y_lim_clust) +
#     scale_x_continuous(breaks = zoom_range_seq_clust,
#                        labels = zoom_range_seq_clust,
#                        limits = x_lim_clust) +
#     geom_vline(aes(xintercept = last_date_clust), col = "red")+
#     theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))
# 
# # Add lin data
# lin_hm_clust <- gheatmap(gg_clust_tree, lin_data,
#                    width = width_clust,
#                    offset = 0,
#                    color = NULL,
#                    colnames_position = "top",
#                    colnames_angle = angle,
#                    # colnames_offset_y = 1,
#                    hjust = 0,
#                    font.size = 3) +
#   scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
#   labs(fill = "Lineage")
# 
# lin_hm_clust <- lin_hm_clust + ggnewscale::new_scale_fill()
# 
# # Add DR status clusters
# dr_status_hm_clust <- gheatmap(lin_hm_clust, dr_status_data,
#                          width = width_clust,
#                          offset = offset_clust,
#                          color = NULL,
#                          colnames_position = "top",
#                          colnames_angle = angle,
#                          # colnames_offset_y = 1,
#                          hjust = 0,
#                          font.size = 3) +
#   scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
#   labs(fill = "DR\nstatus")
# 
# dr_status_hm_clust <- dr_status_hm_clust + ggnewscale::new_scale_fill()
# 
# final_plot <- gheatmap(dr_status_hm_clust, dr_data,
#          width = width_clust * ncol(dr_data),
#          # offset = ceiling(offset_clust * 3),
#          offset = (offset_clust * 2) + (offset_clust * 0.2),
#          # color = NULL,
#          low="white", high="black", color="black",
#          colnames_position = "top",
#          colnames_angle = angle,
#          colnames_offset_y = 0,
#          hjust = 0,
#          font.size = 2.5,
#          legend_title = "llw") +
#   scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
#   labs(fill = "Drug\nresistance")
# 
# print(final_plot)
# }
# # dev.off()


```
-->

***

```{r beastlogplots, echo=FALSE, out.width = "1500px", fig.cap = "Trace plots of BEAST MCMC iterations across posterior, likelihood, prior and MRCA parameters. The plots show no upward or downward trend, hence imply convergence."}

par(mfrow = c(2, 2))

plot(beast_log$posterior, main = "posterior", type= 'l', ylab = "posterior")
plot(beast_log$likelihood, main = "likelihood", type= 'l', ylab = "likelihood")
plot(beast_log$prior, main = "prior", type= 'l', ylab = "prior")
plot(beast_log$mrca.date.forward.TreePrior., main = "MRCA", type= 'l', ylab = "MRCA")

par(mfrow=c(1,1))

```




### References













