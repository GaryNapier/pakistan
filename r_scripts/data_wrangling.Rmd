---
title: "Characterisation of drug-resistant Mycobacterium tuberculosis mutations and transmission in Pakistan"
output: 
  bookdown::word_document2: 
    fig_caption: yes
    table_caption: yes
    number_sections: no
bibliography: all_refs.bib
csl: biomed-central.csl
---

```{r setup, include=FALSE}

# SETUP ----

rm(list = ls())

knitr::opts_chunk$set(echo = F)
library(knitr)
library(dplyr)
library(tidyr)
library(janitor)
library(qgraph)
library(ape)
library(phytools)
library(coda)
library(ggplot2)
library(ggtree)
library(treeio)
library(scales)
library(gplots)
library(RColorBrewer)
library(randomcoloR)
library(usedist)
library(phytools)
library(sp)
library(english)
library(corrplot)
library(chisq.posthoc.test)
knitr::opts_chunk$set(echo = F)
# options(scipen=1, digits=2)
options(scipen=999, digits = 3)
table_font_sz <- 8

```

```{r functions, echo = F}

# FUNCTIONS ----

heaD <- function(x,...){
  head(x, ...)
}

fmt <- function(x, ...){format(x, big.mark=",",scientific=FALSE, ...)}

len_str <- function(string){
  length(unlist(strsplit(string, split = "")))
}

hs <- function(x, ...){
  print(head(x, ...))
  print("---")
  str(x, ...)
}

to_table <- function(x, pc_dir = "row"){
  # pc_dir = the direction to use for calculating percentages. One of "row", "col", or "all".
  x <- x %>% adorn_totals(c("row", "col")) %>%
    adorn_percentages(c(pc_dir)) %>%
    adorn_pct_formatting(digits = 2)
  formatted_ns <- attr(x, "core") %>% # extract the tabyl's underlying Ns
    adorn_totals(c("row", "col")) %>% # to match the data.frame we're appending to
    dplyr::mutate_if(is.numeric, format, big.mark = ",")
  x %>% adorn_ns(position = "front", ns = formatted_ns)
}

log10_ceiling <- function(x) {
  10^(ceiling(log10(x)))
}

tab2df <- function(tab){
  df <- data.frame(x = matrix(tab, ncol = length(tab)))
  names(df) <- names(tab)
  df
}

print_vect <- function(x){
  gsub(".{1}$", "", paste0(x, sep = ",", collapse = " "))
}

drop_cols <- function(x, cnames){
  x[!(names(x) %in% cnames)]
}

plot.phylo.to.map <- function (x, type = c("phylogram", "direct"), ...) 
{
  type <- type[1]
  if (class(x) == "phylo.to.map") {
    tree <- x$tree
    map <- x$map
    coords <- x$coords
  }
  else stop("x should be an object of class \"phylo.to.map\"")
  if (hasArg(xlim)) 
    xlim <- list(...)$xlim
  else xlim <- map$range[1:2]
  if (hasArg(ylim)) 
    ylim <- list(...)$ylim
  else ylim <- map$range[3:4]
  if (hasArg(fsize)) 
    fsize <- list(...)$fsize
  else fsize <- 1
  if (hasArg(split)) 
    split <- list(...)$split
  else split <- c(0.4, 0.6)
  if (hasArg(psize)) 
    psize <- list(...)$psize
  else psize <- 1
  if (hasArg(cex.points)) {
    cex.points <- list(...)$cex.points
    if (length(cex.points) == 1) 
      cex.points <- c(0.6 * cex.points, cex.points)
  }
  else cex.points <- c(0.6 * psize, psize)
  if (hasArg(mar)) 
    mar <- list(...)$mar
  else mar <- rep(0, 4)
  if (hasArg(asp)) 
    asp <- list(...)$asp
  else asp <- 1
  if (hasArg(ftype)) 
    ftype <- list(...)$ftype
  else ftype <- "reg"
  ftype <- which(c("off", "reg", "b", "i", "bi") == ftype) - 
    1
  if (!ftype) 
    fsize = 0
  if (hasArg(from.tip)) 
    from.tip <- list(...)$from.tip
  else from.tip <- FALSE
  if (hasArg(colors)) 
    colors <- list(...)$colors
  else colors <- "red"
  if (length(colors) == 1) 
    colors <- rep(colors[1], 2)
  if (length(colors) == 2 && type == "phylogram") {
    colors <- matrix(rep(colors, nrow(coords)), nrow(coords), 
                     2, byrow = TRUE)
    rownames(colors) <- rownames(coords)
  }
  if (hasArg(direction)) 
    direction <- list(...)$direction
  else direction <- "downwards"
  if (hasArg(pch)) 
    pch <- list(...)$pch
  else pch <- 21
  if (length(pch) == 1) 
    pch <- rep(pch, 2)
  if (hasArg(lwd)) 
    lwd <- list(...)$lwd
  else lwd <- c(2, 1)
  if (length(lwd) == 1) 
    lwd <- rep(lwd, 2)
  if (hasArg(lty)) 
    lty <- list(...)$lty
  else lty <- "dashed"
  if (hasArg(pts)) 
    pts <- list(...)$pts
  else pts <- TRUE
  if (type == "phylogram") {
    if (direction == "downwards") {
      if (!ftype) 
        ylim <- c(ylim[1], ylim[2] + 0.03 * diff(ylim))
      ylim <- c(ylim[1], ylim[2] + split[1]/split[2] * 
                  (ylim[2] - ylim[1]))
    }
    else if (direction == "rightwards") {
      if (!ftype) 
        xlim <- c(xlim[1] - 0.03 * diff(xlim), xlim[2])
      xlim <- c(xlim[1] - split[1]/split[2] * (xlim[2] - 
                                                 xlim[1]), xlim[2])
    }
  }
  par(mar = mar)
  plot.new()
  plot.window(xlim = xlim, ylim = ylim, asp = asp)
  map(map, add = TRUE, fill = TRUE, col = "black", border="grey", mar = rep(0, 
                                                                            4))
  if (type == "phylogram") {
    cw <- reorder(tree, "cladewise")
    n <- Ntip(cw)
    if (direction == "downwards") {
      dx <- abs(diff(xlim))
      rect(xlim[1] - 1.04 * dx, ylim[2] - split[1] * (ylim[2] - 
                                                        ylim[1]), xlim[2] + 1.04 * dx, ylim[2], col = "white", 
           border = "white")
      pdin <- par()$din[2]
      sh <- (fsize * strwidth(paste(" ", cw$tip.label, 
                                    sep = "")) + 0.3 * fsize * strwidth("W")) * (par()$din[1]/par()$din[2]) * 
        (diff(par()$usr[3:4])/diff(par()$usr[1:2]))
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (ylim[2] - ylim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      x <- vector(length = n + cw$Nnode)
      x[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (xlim[2] - xlim[1]) + xlim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        xx <- x[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        x[nn[i]] <- mean(range(xx))
      }
      Y <- ylim[2] - nodeHeights(cw)
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(x[i], coords[i, 1]), c(Y[which(cw$edge[, 
                                                                    2] == i), 2] - if (from.tip) 0 else sh[i], coords[i, 
                                                                                                                      2]), col = colors[cw$tip.label, ][i, 1], lty = lty, 
                           lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(Y)) lines(rep(x[cw$edge[i, 2]], 
                                     2), Y[i, ], lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(range(x[cw$edge[which(cw$edge[, 
                                                                    1] == i), 2]]), Y[which(cw$edge[, 1] == i), 1], 
                                      lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(x[i], Y[which(cw$edge[, 2] == i), 2], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = c(0, 1), srt = -90, 
               cex = fsize, font = ftype)
        if (pts) 
          points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                     2], col=colors[cw$tip.label, 
                                                                                    2])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = fsize * 
                   strwidth(" ")/(par()$usr[2] - par()$usr[1]) * 
                   (par()$usr[4] - par()$usr[3]), x.lim = par()$usr[1:2], 
                 y.lim = par()$usr[3:4], direction = direction, 
                 tip.color = "black", Ntip = Ntip(cw), Nnode = cw$Nnode, 
                 edge = cw$edge, xx = x, yy = sapply(1:(Ntip(cw) + 
                                                          cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                     y = Y, z = cw$edge))
    }
    else {
      dy <- abs(diff(ylim))
      rect(xlim[1], ylim[1], xlim[1] + split[1] * (xlim[2] - 
                                                     xlim[1]), ylim[2], col = "white", border = "white")
      sh <- fsize * strwidth(paste(" ", cw$tip.label, sep = "")) + 
        0.2 * fsize * strwidth("W")
      cw$edge.length <- cw$edge.length/max(nodeHeights(cw)) * 
        (split[1] * (xlim[2] - xlim[1]) - max(sh))
      pw <- reorder(cw, "postorder")
      y <- vector(length = n + cw$Nnode)
      y[cw$edge[cw$edge[, 2] <= n, 2]] <- 0:(n - 1)/(n - 
                                                       1) * (ylim[2] - ylim[1]) + ylim[1]
      nn <- unique(pw$edge[, 1])
      for (i in 1:length(nn)) {
        yy <- y[pw$edge[which(pw$edge[, 1] == nn[i]), 
                        2]]
        y[nn[i]] <- mean(range(yy))
      }
      H <- nodeHeights(cw)
      X <- xlim[1] + H
      coords <- coords[cw$tip.label, 2:1]
      for (i in 1:n) lines(c(X[which(cw$edge[, 2] == i), 
                               2] + if (from.tip) 0 else sh[i], coords[i, 1]), 
                           c(y[i], coords[i, 2]), col = colors[cw$tip.label, 
                                                               ][i, 1], lty = lty, lwd = lwd[2])
      points(coords, pch = pch, cex = cex.points[2], bg = colors[cw$tip.label, 
                                                                 2], col=colors[cw$tip.label, 
                                                                                2])
      for (i in 1:nrow(X)) lines(X[i, ], rep(y[cw$edge[i, 
                                                       2]], 2), lwd = lwd[1], lend = 2)
      for (i in 1:cw$Nnode + n) lines(X[which(cw$edge[, 
                                                      1] == i), 1], range(y[cw$edge[which(cw$edge[, 
                                                                                                  1] == i), 2]]), lwd = lwd[1], lend = 2)
      for (i in 1:n) {
        if (ftype) 
          text(X[which(cw$edge[, 2] == i), 2], y[i], 
               paste(" ", sub("_", " ", cw$tip.label[i]), 
                     sep = ""), pos = 4, offset = 0.1, cex = fsize, 
               font = ftype)
        if (pts) 
          points(X[which(cw$edge[, 2] == i), 2], y[i], 
                 pch = 21, bg = colors[cw$tip.label, ][i, 
                                                       2], cex = cex.points[1])
      }
      PP <- list(type = "phylogram", use.edge.length = TRUE, 
                 node.pos = 1, show.tip.label = if (ftype) TRUE else FALSE, 
                 show.node.label = FALSE, font = ftype, cex = fsize, 
                 adj = 0, srt = 0, no.margin = FALSE, label.offset = 0.1, 
                 x.lim = par()$usr[1:2], y.lim = par()$usr[3:4], 
                 direction = direction, tip.color = "black", Ntip = Ntip(cw), 
                 Nnode = cw$Nnode, edge = cw$edge, xx = sapply(1:(Ntip(cw) + 
                                                                    cw$Nnode), function(x, y, z) y[match(x, z)], 
                                                               y = X, z = cw$edge), yy = y)
    }
    assign("last_plot.phylo", PP, envir = .PlotPhyloEnv)
  }
  else if (type == "direct") {
    phylomorphospace(tree, coords[, 2:1], add = TRUE, label = "horizontal", 
                     node.size = c(0, psize), lwd = lwd[2], control = list(col.node = setNames(rep(colors[2], 
                                                                                                   max(tree$edge)), 1:max(tree$edge)), col.edge = setNames(rep(colors[1], 
                                                                                                                                                               nrow(tree$edge)), tree$edge[, 2])), ftype = c("off", 
                                                                                                                                                                                                             "reg", "b", "i", "bi")[ftype + 1], fsize = fsize)
  }
}


```

```{r variables, echo = F}


# VARIABLES ----


id_col <- "wgs_id"
rnd <- 2
drugs <- c("rifampicin", "isoniazid", "ethambutol", "pyrazinamide", "streptomycin", 
             "ofloxacin", "moxifloxacin", "levofloxacin", "amikacin", "kanamycin", "capreomycin", "ciprofloxacin", "prothionamide", 
             "ethionamide", "para_aminosalicylic_acid", "cycloserine",
             "clarithromycin", "clofazimine", "bedaquiline", "linezolid", "rifabutin", "delamanid")
fq <- "fluoroquinolones, ofloxacin, levofloxacin, ciprofloxacin, moxifloxacin"
agc <- "capreomycin, streptomycin, amikacin, kanamycin, aminoglycosides"
align <- c("l", "r", "r")
col <- "cornflowerblue"
threshold <- 10
threshold_vect <- c(0, 1, seq(5, 50, 5))
plot_text_sz <- 0.5
main_cex <- 1.5
dr_status_vect <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other")

```

```{r paths, echo = F}


# PATHS ----


methods_path <- "../methods/"
metadata_path <- "../metadata/"
newick_path <- "../newick/"
plots_path <- "../plots/"
db_path <- "../../pipeline/db/"
dist_path <- "../dist_and_pca/"
beast_results_path <- "../beast_results/"

```

```{r files, echo = F}


# FILES ----


# Metadata
metadata_file <- paste0(metadata_path, "pakistan_metadata.csv")
historical_metadata_file <- paste0(metadata_path, "historical_metadata.csv") # http://www.pasteur-guadeloupe.fr/
# Database data
lineage_conversion_file <- paste0(db_path, "lineage_conversions.txt")
dr_genes_file <- paste0(db_path, "tbdb.bed")
# Distance
dist_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist")
dist_id_file <- paste0(dist_path, "PAKISTAN_ALL.dist.dist.id")
# Trees
tree_all_samps_newick_file <- paste0(newick_path, "PAKISTAN_ALL.filt.val.gt.g.snps.fa.treefile")
# Beast
beauti_params_file <- paste0(methods_path, "beauti_parameters.csv")
mcc_tree_file <- paste0(beast_results_path, "PAKISTAN_ALL.mcc.tree")
beast_log_file <- paste0(beast_results_path, "PAKISTAN_ALL.dated.log")
beast_clusters_file <- paste0(metadata_path, "PAKISTAN_ALL.clusters.csv")
# Drug resistance
dr_variants_file <- paste0(metadata_path, "PAKISTAN_ALL.variants.dr.txt")
other_variants_file <- paste0(metadata_path, "PAKISTAN_ALL.variants.other.txt")
# Images
tree_all_samps_file <- paste0(plots_path, "PAKISTAN_ALL.tree.png")
beast_clusters_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.beast_clusters.pdf")
dr_trees_pdf_file <- paste0(plots_path, "PAKISTAN_ALL.dr_trees.pdf")
# Map
pakistan_sp_file <- paste0(metadata_path, "pakistan_sp.rds")
pakistan_lat_long_file <- paste0(metadata_path, "pakistan_lat_long.csv")
pakistan_province_lookup_file <- paste0(metadata_path, "pakistan_province_lookup.csv")
# ASR
asr_file <- paste0(plots_path, "asr_tree.png")
# Methods
methods_file <- paste0(methods_path, "pakistan_methods.tsv")

```

```{r read_in_data, echo = F, warning=F}


# READ IN DATA ----


# Metadata
metadata <- read.csv(metadata_file)
historical_metadata <- read.csv(historical_metadata_file)
# Database data
lineage_conversions <- read.delim(lineage_conversion_file)
dr_genes <- read.delim(dr_genes_file, header = F)
# Dist
dist <- read.delim(dist_file, header = F)
dist_id <- read.delim(dist_id_file, header = F)
# Trees
tree_all_samps <- read.newick(tree_all_samps_newick_file)
# Beast
beauti_params <- read.csv(beauti_params_file)
mcc_tree_ape <- ape::read.nexus(mcc_tree_file)
mcc_tree <- treeio::read.beast(mcc_tree_file)
beast_log <- tracerer::parse_beast_log(beast_log_file)
beast_clusters <- read.csv(beast_clusters_file, header = F, col.names = c("cluster", "id"))
# Drug resistance
dr_variants <- read.delim(dr_variants_file, header = T)
other_variants <- read.delim(other_variants_file, header = T)
# Map
pakistan_sp <- readRDS(pakistan_sp_file)
pakistan_lat_long <- read.csv(pakistan_lat_long_file, header = T)
pakistan_province_lookup <- read.csv(pakistan_province_lookup_file, header = T)
# Other
methods_table <- read.table(file = methods_file, sep = '\t', header = TRUE)

```

```{r basic-wrangling, echo = F}


# BASIC WRANGLING ----


n_samps_total <- length(metadata$wgs_id)
n_snps_total <- 37970

# Subset metadata to just those with a year
metadata_dated <- subset(metadata, !(is.na(metadata$year)))
dated_samps <- metadata_dated$wgs_id

n_dated_samps <- length(dated_samps)

first_year <- min(metadata_dated$year)
last_year <- max(metadata_dated$year)

cutoff_year <- 50

# -----

# Drugs
n_drugs_total <-ncol(dplyr::select(metadata, rifampicin_test:delamanid_test))

# How many drugs phenotypically tested?
pheno_tests <- dplyr::select(metadata, rifampicin:delamanid)
pheno_test_names <- names(pheno_tests[,apply(pheno_tests, 2, function(x) {!(all(is.na(x)))} )])
n_pheno_tests <- length(pheno_test_names)
pheno_test_names <- gsub('.$', '', paste0(pheno_test_names, ",", collapse = " "))

# ----

# Dated samps
n_dated_samps <- sum(!(is.na(metadata$year)))

# ----

# Publication years
pub_years <- as.numeric(gsub(".*?([0-9]+).*", "\\1", metadata$study_name))


```

```{r wrangle-distance, echo=F}


# DISTANCE ----

# Add row and col names to distance matrix
colnames(dist) <- dist_id[, 1]
row.names(dist) <- dist_id[, 1]
# Divide dist matrix by 2 
dist <- dist/2
# Get lower only
# lower_dist <- dist[lower.tri(dist)]
# dist_dated <- dist[dated_samps, dated_samps]

# Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
dist[upper.tri(dist, diag = T)] <- 0
lower_dist <- dist[lower.tri(dist)]

# Do density plot of distance matrix for all samples
lower_dist_df <- data.frame(lower_dist)
dist_dens_all_samples <- ggplot()+
  geom_density(data = lower_dist_df, aes(x = lower_dist))+
  theme_classic()+
  xlab(label = "SNP distance")

# Cluster using 'single' method.
# Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
clust <- hclust(as.dist(dist), method = "single")

# Cut tree at threshold to find samples within threshold
clusters <- sort(cutree(clust, h = threshold))

# Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# Gets samples below the threshold
clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
n_clusters_cut_tree <- length(unique(clusters))

# Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
dist_thresh <- as.dist(dist[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.
dist_thresh <- dist_thresh+1 # Add 1 because 1/x later.

```

```{r wrangle-location, echo=F}


# LOCATION ----


# Clean blanks in location
# metadata$location <- ifelse(metadata$location == "", NA, metadata$location)
metadata$location <- ifelse(metadata$location == "" | is.na(metadata$location), "Missing", metadata$location)

# Convert to 'other' if less than 5 samples
other_locs <- names(table(metadata$location)[table(metadata$location) < 5])
metadata$location_other <- ifelse(metadata$location %in% other_locs, "Other", metadata$location)

# Add province and district
metadata <- merge(metadata, pakistan_province_lookup, by = "location", all.x = T, sort = F)

# Add province lat long
province_lat_long_df <- merge(metadata["province"], pakistan_lat_long, by.x = "province", by.y = "location", all.x = T, sort = F)
names(province_lat_long_df) <- c("province", "province_lat", "province_long")
province_lat_long_df <- unique(province_lat_long_df)
metadata <- merge(metadata, province_lat_long_df, by = "province", all.x = T, sort = F)

# Pivot table of locations
# location_tab <- reshape2::dcast(metadata, location ~ "N", value.var = id_col, fun.aggregate = length)
# location_tab$pc <- round((location_tab$N/sum(location_tab$N)) * 100, rnd)
# location_tab <- location_tab[order(location_tab$N, decreasing =T),]

location_tab <- reshape2::dcast(metadata, location_other ~ "N", value.var = id_col, fun.aggregate = length)
location_tab$pc <- round((location_tab$N/sum(location_tab$N)) * 100, rnd)
location_tab <- location_tab[order(location_tab$N, decreasing =T),]
names(location_tab) <- c("location", "N", "pc")


```

```{r in-transmission-stats, echo=F, warning = F}

# Take the samples from the above "clusters" variable - these samples are "in transmission"
# Find their metadata and put into a table
in_trans_metadata <- metadata[metadata[,"wgs_id"] %in% names(clusters), ]

# ---

# FOR TABLE


metadata$trans_status <- ifelse(metadata[,"wgs_id"] %in% names(clusters), "in_trans", "not_in_trans")

round_to <- 1

trans_lin_pivot <- reshape2::dcast(metadata, main_lineage ~ trans_status, value.var = "trans_status", fun.aggregate = length)
trans_lin_pivot$in_trans_pc <- round((trans_lin_pivot$in_trans/sum(trans_lin_pivot$in_trans))*100, round_to)
trans_lin_pivot$not_in_trans_pc <- round((trans_lin_pivot$not_in_trans/sum(trans_lin_pivot$not_in_trans))*100, round_to)

trans_dr_pivot <- reshape2::dcast(metadata, dr_status ~ trans_status, value.var = "trans_status", fun.aggregate = length)
trans_dr_pivot <- trans_dr_pivot[order(match(trans_dr_pivot$dr_status, dr_status_vect)), ]
trans_dr_pivot$in_trans_pc <- round((trans_dr_pivot$in_trans/sum(trans_dr_pivot$in_trans))*100, round_to)
trans_dr_pivot$not_in_trans_pc <- round((trans_dr_pivot$not_in_trans/sum(trans_dr_pivot$not_in_trans))*100, round_to)


trans_loc_pivot <- reshape2::dcast(metadata, location_other ~ trans_status, value.var = "trans_status", fun.aggregate = length)
trans_loc_pivot$in_trans_pc <- round((trans_loc_pivot$in_trans/sum(trans_loc_pivot$in_trans))*100, round_to)
trans_loc_pivot$not_in_trans_pc <- round((trans_loc_pivot$not_in_trans/sum(trans_loc_pivot$not_in_trans))*100, round_to)


trans_df <- rbind(trans_lin_pivot, 
                  setNames(trans_dr_pivot, names(trans_lin_pivot)), 
                  setNames(trans_loc_pivot, names(trans_lin_pivot)))


trans_df$category <- c(rep("Lineage", nrow(trans_lin_pivot)), 
                       rep("DR status", nrow(trans_dr_pivot)), 
                       rep("Location", nrow(trans_loc_pivot)))

names(trans_df)[1] <-"X"

trans_df <- trans_df[, c("category", "X", "in_trans", "in_trans_pc", "not_in_trans", "not_in_trans_pc")]

# ------


# Make df of samples in and not in transmission
trans_samps <- names(clusters)
non_trans_samps <- metadata[!(metadata[,"wgs_id"] %in% trans_samps), "wgs_id"]
trans_non_trans_df <- data.frame(id = c(trans_samps, non_trans_samps), trans_status = c(rep(1, length(trans_samps)), rep(0, length(non_trans_samps))))

# Write out trans_non_trans_df
write.csv(trans_non_trans_df, file = "../metadata/trans.csv", row.names = F, quote = F, col.names = F)

# Lineage
lin <- tab2df(table(in_trans_metadata$main_lineage))
# DR
dr <- tab2df(table(in_trans_metadata$dr_status))
dr <- dr[, dr_status_vect]

# Loc -
# n.b. have to do all this messy wrangling because not all locs are represented in transmission,
# so need a pivot table that includes all the 0s
# loc <- tab2df(table(in_trans_metadata$location))
# loc_data <- metadata[, c("wgs_id", "location")]
loc_data <- metadata[, c("wgs_id", "location_other")]
loc_data$trans_status <- ifelse(loc_data$wgs_id %in% names(clusters), 1, 0)
loc_data$location <- ifelse(loc_data$location == "", NA, loc_data$location)
loc_piviot <- reshape2::dcast(loc_data, trans_status ~ location, value.var = "trans_status",
                              fun.aggregate = length)
loc <- loc_piviot[loc_piviot[, "trans_status"] == 1, !(names(loc_piviot) %in% "trans_status")]

# Put all together
in_trans_df <- t(cbind(lin, dr, loc))
in_trans_df_rows <- row.names(in_trans_df)
in_trans_df <- data.frame(in_trans_df)
names(in_trans_df) <- "N"
in_trans_df$pc <- (in_trans_df$N/length(clusters))*100
# in_trans_df$X <- row.names(in_trans_df)
in_trans_df$X <- in_trans_df_rows
in_trans_df$Y <- c(rep("Lineage", length(lin)), rep("DR status", length(dr)), rep("Location", length(loc)))
row.names(in_trans_df) <- NULL
in_trans_df <- in_trans_df[, c("Y", "X", "N", "pc")]
names(in_trans_df) <- c("", "", "N", "pc")
row.names(in_trans_df) <- NULL


# -----

# Tests and plots - chi sq etc

# Lineage

# Row-bind the samples that are 'in transmission' vs non-in-transmission, by lineage
lin_contingency_tab <- rbind(lin, tab2df(table(metadata[!(metadata[,"wgs_id"] %in% names(clusters)), ]$main_lineage)))
row.names(lin_contingency_tab) <- c("yes", "no")

# Make df
lin_contingency_tab_df <- lin_contingency_tab

# Convert the data as a table
lin_contingency_tab <- as.table(as.matrix(lin_contingency_tab))

# Do test
trans_lin_chi_sq <- chisq.test(lin_contingency_tab)

# Do post-hoc test
trans_lin_chi_sq_ph <- chisq.posthoc.test(lin_contingency_tab)

# DR status

# Row-bind the samples that are 'in transmission' vs non-in-transmission, by DR
dr_contingency_tab <- rbind(dr, tab2df(table(metadata[!(metadata[,"wgs_id"] %in% names(clusters)), ]$dr_status)))
row.names(dr_contingency_tab) <- c("yes", "no")

# Make df
dr_contingency_tab_df <- dr_contingency_tab

# Convert the data as a table
dr_contingency_tab <- as.table(as.matrix(dr_contingency_tab))

# Do test
trans_dr_chi_sq <- chisq.test(dr_contingency_tab, simulate.p.value = T)
# Do post hoc test
trans_dr_chi_sq_ph <- chisq.posthoc.test(dr_contingency_tab)

# Location

# Row-bind the samples that are 'in transmission' vs non-in-transmission, by loc
loc_contingency_tab <- loc_piviot[, !(names(loc_piviot) %in% "trans_status")]
# Swap the rows
loc_contingency_tab <- loc_contingency_tab[c(2, 1), ]
row.names(loc_contingency_tab) <- c("yes", "no")

# Make df
loc_contingency_tab_df <- loc_contingency_tab

# Convert the data as a table
loc_contingency_tab <- as.table(as.matrix(loc_contingency_tab))
# Do test
trans_loc_chi_sq <- chisq.test(loc_contingency_tab, simulate.p.value = T)
# Do post-hoc test
trans_loc_chi_sq_ph <- chisq.posthoc.test(loc_contingency_tab)



# Odds ratios

# MAKE FUNCTION FOR COL OF INTEREST AFTER CHI-SQ POST-HOC TESTS
or <- function(x, column){

  # Get the odds ratio for a contingengy table of dimensions 2 x (>2)
  # Input is a dataframe
  
  # e.g. With dataframe:
  #        A   B   C   D
  # yes    7   21  98  43
  # no     15  15  299 37
  
  # If we're interested in column B, the function column-binds the sum of the other column rows with column B:
  
  #       A   C   D
  # yes   7   98  43
  # no    15  299 37
  
  # > sum > 
  
  #        [,1]
  # [1,]  148
  # [2,]  351
  
  # > column-bind with col B >
  
  #        B   not-B
  # yes    21  148
  # no     15  351
  
  # Then do this calculation to get the odds ratio:  (a*d)/(b*c)
  # Where 
  
  #        B  not-B
  # yes    a  b
  # no     c  d
  
  not_df <- x[!(names(x) %in% column)]
  df <- setNames(cbind(x[column], rbind(sum(not_df[1, ]), sum(not_df[2, ]))), c(column, "not"))
  
  a <- df[1, 1]
  b <- df[1, 2]
  c <- df[2, 1]
  d <- df[2, 2]
  
  (a*d)/(b*c)

}

# Lin
or(lin_contingency_tab_df, "2")
or(lin_contingency_tab_df, "4")

or(dr_contingency_tab_df, "Pre-XDR")
or(dr_contingency_tab_df, "XDR")

or(loc_contingency_tab_df, "Peshawar")

```

```{r dist-sensitivity, echo=F}

# Loop over the SNP dist threshold vector and do the clustering
clusters_list <- list()
for(i in seq(threshold_vect)){
  # Cut tree at threshold to find samples within threshold
  clusters_list[[i]] <- sort(cutree(clust, h = threshold_vect[i]))  
  clusters_list[[i]] <- clusters_list[[i]][clusters_list[[i]] %in% names(which(table(clusters_list[[i]]) > 1)) ]
}

# Get the numbers about the clusters
n_clusts_vect <- unlist(lapply(clusters_list, function(x) length(unique(x))))
n_samps_per_cluster_vect <- unlist(lapply(clusters_list, function(x) length(x)))
med_samps_clusts <- unlist(lapply(clusters_list, function(x) median(table(x))))
min_samps_clusts <- unlist(lapply(clusters_list, function(x) min(table(x))))
max_samps_clusts <- unlist(lapply(clusters_list, function(x) max(table(x))))

# Take the samples that are in the clusters and get all the metadata
metadata_clust_list <- lapply(clusters_list, function(x){
  metadata[metadata[,"wgs_id"] %in% names(x), ]
  })

# Get the lineage stats for the clusters
n_lin_clusts <- data.frame(do.call("rbind", lapply(metadata_clust_list, function(x){
  table(x$main_lineage)
  })))
names(n_lin_clusts) <- paste0("Lin_", 1:ncol(n_lin_clusts))

# Same for dr status
n_dr_clusts <- plyr::rbind.fill(lapply(metadata_clust_list, function(x){
  tab2df(table(x$dr_status))
  }))
n_dr_clusts <- n_dr_clusts[, dr_status_vect] # Re-arrange

dist_sensitivity_table <- data.frame(SNP_dist = threshold_vect, 
                                     N_clusters = n_clusts_vect, 
                                     N = n_samps_per_cluster_vect, 
                                     Median = med_samps_clusts, 
                                     Min = min_samps_clusts, 
                                     Max = max_samps_clusts, 
                                     n_lin_clusts,
                                     n_dr_clusts)


# Threshold stats
med_clust_threshold <- dist_sensitivity_table[dist_sensitivity_table["SNP_dist"] == threshold, "Median"]
min_clust_threshold <- dist_sensitivity_table[dist_sensitivity_table["SNP_dist"] == threshold, "Min"]
max_clust_threshold <- dist_sensitivity_table[dist_sensitivity_table["SNP_dist"] == threshold, "Max"]

```

```{r wrangle-lineages, echo=F}


# LINEAGES ----


lin_tab <- reshape2::dcast(metadata, main_lineage ~ "N", value.var = id_col, fun.aggregate = length)
names(lin_tab) <- c("Lineages", names(lin_tab)[length(names(lin_tab))])
lin_tab$pc <- round((lin_tab$N/sum(lin_tab$N)) * 100, rnd)


n_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "N"]
pc_lin_1 <- lin_tab[lin_tab["Lineages"] == 1, "pc"]
n_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "N"]
pc_lin_2 <- lin_tab[lin_tab["Lineages"] == 2, "pc"]
n_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "N"]
pc_lin_3 <- lin_tab[lin_tab["Lineages"] == 3, "pc"]
n_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "N"]
pc_lin_4 <- lin_tab[lin_tab["Lineages"] == 4, "pc"]


# Lineages conversions
lin_conv <- merge(metadata[c("main_lineage", "sub_lineage")], lineage_conversions, 
                  by.x = "sub_lineage", by.y = "mtbc_lineage", 
                  all.x = T, sort = F)
lin_conv_tab <- reshape2::dcast(lin_conv, sub_lineage + lsp_lineage + spoligotype_family + rd_number ~ "N",
                                value.var = "sub_lineage", fun.aggregate = length)
lin_conv_tab$pc <- (lin_conv_tab$N / sum(lin_conv_tab$N)) * 100
names(lin_conv_tab) <- c("Lineage", "LSP lineage", "Spoligotype family", "Region of difference no.", "N", "%")
lin_conv_tab <- lin_conv_tab[order(lin_conv_tab$N, decreasing = T),]
row.names(lin_conv_tab) <- NULL


# Get unique lineages
uniq_lins <- unique(metadata$sub_lineage)


```

```{r wrangle-years, echo=F}


# YEARS ----

metadata$year_round <- round(as.numeric(metadata$year, 1))

year_tab <- reshape2::dcast(metadata, year_round ~ "N", value.var = id_col, fun.aggregate = length)
year_tab$pc <- round((year_tab$N/sum(year_tab$N)) * 100, rnd)

```

```{r wrangle-map, echo = F, message = F, warning = F}

# Not sure what this does
pakistan_sp@data$name <- pakistan_sp@data$NAME_1
# Read in tree again (use ape because read.tree is presumably different to read.newick)
map_tree <- ape::read.tree(tree_all_samps_newick_file)
# Merge lat long data with metadata
metadata <- merge(metadata, pakistan_lat_long, 
                  by = "location", 
                  all.x = T, 
                  sort = F)
# Sort
locations <- metadata[match(map_tree$tip.label, metadata$wgs_id), ]
# Make df of just lat long, sort (not sure the sort is needed), and add rownames
lat_long <- data.frame(lat = locations$lat, long = locations$long)
lat_long <- lat_long[match(map_tree$tip.label, locations$wgs_id), ]
rownames(lat_long) <- map_tree$tip.label
# Colours
regions_uniq <- unique(locations$location)
regions_cols <- rainbow(length(regions_uniq))
map_cols <- matrix(rep(regions_cols[match(locations$location, regions_uniq)], 2),
               nrow(locations), 2, byrow=F)
rownames(map_cols) <- locations$wgs_id

# Subset to complete cases
lat_long <- lat_long[complete.cases(lat_long), ]
tips <- map_tree$tip.label
map_tree <- keep.tip(map_tree, tips[tips %in% row.names(lat_long)])
names(regions_cols) <- regions_uniq
regions_cols <- regions_cols[!(is.na(names(regions_cols)))]
regions_uniq <- regions_uniq[complete.cases(regions_uniq)]

# Do map
obj <- phylo.to.map(map_tree, lat_long, plot = FALSE, database = pakistan_sp, fill=T)


```

```{r wrangle-tree, echo=F}


# TREE ----


tree_all_samps <- midpoint.root(tree_all_samps)

```

```{r wrangle-beast, echo=F}


# BEAST ----


names(beauti_params) <- c("Beauti tab", "Selection", "Parameter values [min, max]")

# Beast clusters
n_beast_clusters <- length(unique(beast_clusters$cluster))
n_beast_cluster_samps <- nrow(beast_clusters)

```

```{r wrangle-DR-basic, echo=F}


# DR ----


# Specific drugs - phenotypic tests (DST)
drugs_data <- apply(metadata[drugs], 2, as.numeric)
dr_tab <- as.data.frame(t(t(apply(drugs_data[, drugs], 2, sum, na.rm = T))))
dr_tab$N_dst_total <- apply(drugs_data, 2, function(x) sum(!(is.na(x))))
dst_by_row_vect <- apply(drugs_data[, drugs], 1, sum, na.rm = T)
n_samps_dst_res <- n_samps_total - sum(dst_by_row_vect == 0)
dr_tab$drug <- row.names(dr_tab)
names(dr_tab) <- c("N_dst_res", "N_dst_total", "drug")
dr_tab <- dr_tab[c("drug", "N_dst_total", "N_dst_res")]
row.names(dr_tab) <- NULL
dr_tab$pc_dst_resistant <- round((dr_tab$N_dst_res/dr_tab$N_dst_total) * 100, rnd)
dr_tab$pc_dst_resistant_of_total <- round((dr_tab$N_dst_res/n_samps_total) * 100, rnd)


# Genotypic DR - TBprofiler
tbp_drug_tests <- grep("_tbp", names(metadata), value = T)
n_tbp_drug_tests <- length(tbp_drug_tests)-2
tbp_data <- ifelse(metadata[tbp_drug_tests] == "-", 0, 1)
tbp_data <- as.data.frame(t(t(apply(tbp_data, 2, sum, na.rm = T))))
tbp_data$drug <- row.names(tbp_data)
row.names(tbp_data) <- NULL
tbp_data <- tbp_data[, c(2, 1)]
names(tbp_data)[2] <- "N"
tbp_data$pc <- round((tbp_data$N/n_samps_total) * 100, rnd)
tbp_data$drug <- gsub("_tbp", "", tbp_data$drug)

# Discrepancies columns
FN <- "pheno_res; geno_sens"
FP <- "pheno_sens; geno_res"
discrepancy_data <- metadata[, grep("_test", names(metadata), value = T)]
FN_sums <- as.data.frame(t(t(apply(discrepancy_data, 2, function(x) sum(x == FN)))))
FP_sums <- as.data.frame(t(t(apply(discrepancy_data, 2, function(x) sum(x == FP)))))
FN_FP_df <- setNames(cbind(FP_sums, FN_sums), c("FP", "FN"))
FN_FP_df$drug <- row.names(FN_FP_df)
FN_FP_df$drug <- gsub("_test", "", FN_FP_df$drug)

# Put DST, TBprofiler and discrepancies results together
dr_tab <- merge(dr_tab, tbp_data, by = "drug", all = T, sort = F)
dr_tab <- merge(dr_tab, FN_FP_df, by = "drug", all = T, sort = F)
dr_tab_easy <- dr_tab
names(dr_tab_easy) <- c("drug", "N_dst_total", "N_dst_res", "pc_dst_resistant", "pc_dst_resistant_of_total", "N_gen", "pc_gen", "FP", "FN")
names(dr_tab) <- c("Drug", "DST N", "DST N resistant", "DST % resistant", "DST % resistant of total", "N genotypic resistant", "% genotypic resistant", "DST - Geno +", "DST + Geno -")

# DR status
# Desired order of DR cols
dr_vals <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other") 
dr_status_tab <- reshape2::dcast(metadata, dr_status ~ "N", value.var = id_col, fun.aggregate = length)
dr_status_tab <- dr_status_tab[match(dr_vals, dr_status_tab$dr_status), ]
names(dr_status_tab) <- c("Status", names(dr_status_tab)[length(names(dr_status_tab))])
dr_status_tab$pc <- round((dr_status_tab$N/sum(dr_status_tab$N)) *100, rnd)
row.names(dr_status_tab) <- NULL

n_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "N"]
pc_sens <- dr_status_tab[dr_status_tab["Status"] == "Sensitive", "pc"]
n_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "N"]
pc_mdr <- dr_status_tab[dr_status_tab["Status"] == "MDR", "pc"]
n_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "N"]
pc_xdr <- dr_status_tab[dr_status_tab["Status"] == "XDR", "pc"]

# DR status by lineage
dr_lin_tab <- reshape2::dcast(metadata,  dr_status ~ main_lineage, value.var = id_col, fun.aggregate = length)
dr_lin_tab$dr_status <- factor(dr_lin_tab$dr_status, levels = dr_vals)
dr_lin_tab <- dr_lin_tab[order(dr_lin_tab$dr_status), ]
names(dr_lin_tab) <- c("DR status", paste0("L", sort(unique(metadata$main_lineage))))
dr_lin_tab <- to_table(dr_lin_tab, pc_dir = "all")
row.names(dr_lin_tab) <- NULL


```

```{r wrangle-discrepancies-other-variants, echo=F}


# DISCREPANCIES ----


FN <- "pheno_res; geno_sens"
FP <- "pheno_sens; geno_res"
discrepancy_data <- metadata[, grep("_test", names(metadata), value = T)]

# How many SAMPLES are FP or FN?
n_FN_samps <- sum(apply(discrepancy_data == FN, 1, sum) > 0) 
n_FP_samps <- sum(apply(discrepancy_data == FP, 1, sum) > 0)

# write.csv(discrepancy_data, file = "../discrepancy_data.csv", row.names = F)

# 177	pheno_res; geno_sens	pheno_res; geno_sens
# 178	match_res	match_res
# 179	match_res	match_res
# 180	match_res	match_res
# 181	match_res	pheno_res; geno_sens

# x <- data.frame(id = LETTERS[1:5], 
#                 rif = c("pheno_res; geno_sens", rep("match_res", 4)), 
#                 iso = c("pheno_res; geno_sens", rep("match_res", 3), "pheno_res; geno_sens"))

# # How many SAMPLES are FP in x? TWO. The answer should be TWO
# sum(apply(x == FN, 1, sum) > 0)
# sum(apply(x, 2, function(x){sum(x == FN)}))

FN_res <- apply(discrepancy_data, 2, function(x){sum(x == FN)})
FP_res <- apply(discrepancy_data, 2, function(x){sum(x == FP)})

# Add ids in for the other variants stuff
discrepancy_data$wgs_id <- metadata$wgs_id 
# n_FN_samps <- sum(FN_res)
# n_FP_samps <- sum(FP_res)
FN_drugs_split <- names(FN_res[FN_res > 0])
FP_drugs_split <- names(FP_res[FP_res > 0])

# HOW MANY FN TESTS?
sum(apply(discrepancy_data == FN, 1, sum))






# Drug resistance genes lookup table ----

# Convert to one row per drug
names(dr_genes) <- c("chr", "start", "end", "locus", "gene", "drugs")
dr_genes$drugs <- gsub("para-aminosalicylic_acid", "para_aminosalicylic_acid", dr_genes$drugs)
dr_genes <- data.frame(dr_genes %>% 
                         mutate(drugs = strsplit(as.character(drugs), ",")) %>% 
                         unnest(drugs))

dr_genes <- dr_genes[order(dr_genes$drugs), ]


# Other variants ---- 

# Remove Rv3457c locus
other_variants <- other_variants[!(other_variants$locus_tag == "Rv3457c"), ]

# FN
FN_results <- data.frame()
for(i in seq(FN_drugs_split)){
  # Get drug and remove "_test"
  drug <- FN_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FN_samps <- discrepancy_data[discrepancy_data[drug] == FN, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FN_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FN_results <- rbind(ov_sub, FN_results)
}

# TABLE - SUMMARY OF NUMERS - HOW MANY SAMPS 
FN_results_table_pivot <- reshape2::dcast(FN_results, drug + gene + change ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

# Join in total n samps resistant to each drug 
# FN_results_table_pivot <- merge(FN_results_table_pivot, dr_tab_easy[, c("drug", "N_dst", "N_gen")], 
#                                 by = "drug", all.x = T, sort = F)
# 
# # Calc percentages
# FN_results_table_pivot$pc_dst <- (FN_results_table_pivot$N/FN_results_table_pivot$N_dst)*100
# FN_results_table_pivot$pc_gen <- (FN_results_table_pivot$N/FN_results_table_pivot$N_gen)*100
# # Re-order cols
# FN_results_table_pivot <- FN_results_table_pivot[,  c("drug", "gene", "change", "N", "N_dst", "pc_dst", "N_gen", "pc_gen")]

# Other pivots, for easy wrangling:
FN_results_drug_pivot <- reshape2::dcast(FN_results, drug ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

FN_results_gene_pivot <- reshape2::dcast(FN_results, gene ~ "N", value.var = "wgs_id", 
                                          fun.aggregate = function(x){length(unique(x))})

# Neaten table 
FN_results_table <- unique(FN_results[, !(names(FN_results) %in% c("locus_tag_drugs", "wgs_id", "id_year", "nucleotide_change"))])
FN_results_table <- FN_results_table[order(FN_results_table$drug, FN_results_table$gene, FN_results_table$genome_pos), ]
row.names(FN_results_table) <- NULL

# FN_results_table[, !(names(FN_results_table) %in% c(""))]

# n_pza_FN_samps <- length(unique(FN_results[FN_results$drug == "pyrazinamide"]$wgs_id))
# pza_FN_mutations <- unique(FN_results[FN_results$drug == "pyrazinamide"]$change)
# pza_FN_mutations_print <- paste0(pza_FN_mutations, collapse = ", ")
# n_pza_FN_mutations <- length(pza_FN_mutations)

# FP 

FP_results <- data.frame()
for(i in seq(FP_drugs_split)){
  # Get drug and remove "_test"
  drug <- FP_drugs_split[i]
  drug_proper <- gsub("_test", "", drug)
  # Get the FN samples for the drug
  FP_samps <- discrepancy_data[discrepancy_data[drug] == FP, "wgs_id"]
  # Subset the other variants data by the samples
  ov_sub <- other_variants[other_variants[,"wgs_id"] %in% FP_samps, ]
  # Get the loci for the relevant drug
  loci <- dr_genes[dr_genes[, "drugs"] == drug_proper, ]$locus
  # Subset the FN other variants data by the loci associated with the drug  
  ov_sub <- ov_sub[ov_sub[, "locus_tag"] %in% loci, ]
  # Append the drug name (for tidiness/neatness)
  ov_sub$drug <- rep(drug_proper, nrow(ov_sub))
  FP_results <- rbind(ov_sub, FP_results)
}

# Neaten table
FP_results_table <- unique(FP_results[, !(names(FP_results) %in% c("locus_tag_drugs", "wgs_id", "id_year"))])
FP_results_table <- FP_results_table[order(FP_results_table$drug, FP_results_table$gene, FP_results_table$genome_pos), ]
row.names(FP_results_table) <- NULL


# Get stats

# How many TOTAL DST TESTS
total_dst_tests <- sum(apply(drugs_data, 2, function(x) !(is.na(x))))

# Total number of FP TESTS
total_FP <- sum(FP_res)

n_FN_drugs <- length(unique(FN_results_table$drug))
n_FP_drugs <- length(unique(FP_results_table$drug))
FN_drugs <- gsub(".{1}$", "", paste0(unique(FN_results_table$drug), sep = ",", collapse = " "))
FP_drugs <- gsub(".{1}$", "", paste0(unique(FP_results_table$drug), sep = ",", collapse = " "))

# Rifampicin
rif_mutations <- subset(FN_results_table, drug == "rifampicin")$change
n_rpob_mutaion_samps <- subset(FN_results_gene_pivot, gene == "rpoB")

# Isoniazid
iso_data <- subset(FN_results_table, drug == "isoniazid")
iso_mutations <- unique(iso_data$change)
iso_genes <- print_vect(unique(iso_data$gene))
n_iso_samps <- length(unique(FN_results[FN_results$drug == "isoniazid", "wgs_id"]))

```

```{r wrangle-dr-variants, echo=F}

dr_variants$locus_tag_drugs <- gsub(c("\\[|\\]|\\'"), "", dr_variants$locus_tag_drugs)
dr_variants$drug <- dr_variants$locus_tag_drugs
dr_variants <- dr_variants[ ,!(names(dr_variants) %in% "locus_tag_drugs")]
# dr_variants_pivot <- reshape2::dcast(dr_variants,  drug ~ gene, value.var = "wgs_id", fun.aggregate = length)

# Tidy up drug col
dr_variants$drug <- ifelse(dr_variants$drug == fq, "fluoroquinolones", 
       ifelse(dr_variants$drug == agc, "aminoglycosides", dr_variants$drug))

# Make pivot table
dr_variants_pivot <- reshape2::dcast(dr_variants, drug + gene + change ~ "N",
                                     value.var = "wgs_id", 
                                     fun.aggregate = function(x){length(unique(x))})

# Merge with totals for each drug

# DST
dr_variants_pivot <- merge(dr_variants_pivot, dr_tab_easy[, c("drug", "N_dst_total")], 
                           by = "drug", all.x = T, sort = F)
dr_variants_pivot$pc_dst <- (dr_variants_pivot$N/dr_variants_pivot$N_dst_total)*100
dr_variants_pivot$pc_dst <- ifelse(is.infinite(dr_variants_pivot$pc_dst), NA, dr_variants_pivot$pc_dst)

# Genotype - n.b. this has to be merged from itself because the dr_tab_easy doesn't match the known variants table. 
dr_variants_n <- reshape2::dcast(dr_variants, drug ~ "N_gen", value.var = "wgs_id", 
                                     fun.aggregate = function(x){length(unique(x))})
dr_variants_pivot <- merge(dr_variants_pivot, dr_variants_n, by = "drug", all.x = T, sort = F)
dr_variants_pivot$pc_gen <- (dr_variants_pivot$N/dr_variants_pivot$N_gen)*100

dr_variants_results_table <- unique(dr_variants[, !(names(dr_variants) %in% c("wgs_id", "id_year", "nucleotide_change"))])
dr_variants_results_table <- dr_variants_results_table[order(dr_variants_results_table$drug, 
                                                             dr_variants_results_table$gene, 
                                                             dr_variants_results_table$genome_pos), ]
row.names(dr_variants_results_table) <- NULL

```

```{r wrangle-loc-lin-dr-dates-table-1, echo = F}


# TABLE 1 ----


# "Table 1 – locations, lineages, drug resistance, dates of collection…"


table_1 <- data.frame()
table_1 <- rbind(table_1, 
                 setNames(lin_tab, names(table_1)), 
                 setNames(dr_status_tab, names(table_1)), 
                 setNames(dr_tab[, c("Drug", "N genotypic resistant", "% genotypic resistant")], names(table_1)), 
                 setNames(year_tab, names(table_1)), 
                 setNames(location_tab, names(table_1)))

names(table_1) <- c("Characteristic", "N", "%")

table_1$Category <- c(rep("Lineage", nrow(lin_tab)), 
                      rep("DR status", nrow(dr_status_tab)), 
                      rep("Predicted drug resistance", nrow(dr_tab)), 
                      rep("Collection year", nrow(year_tab)),
                      rep("Region", nrow(location_tab)))

table_1 <- table_1[, c( "Category", "Characteristic", "N", "%")]

# table_1 <- table_1[complete.cases(table_1), ]

row.names(table_1) <- NULL



```


| | |
| ----------- | ----------- |
|Gary Napier^1^,* | gary.napier@lshtm.ac.uk |
|Anwar Sheed Khan^2^,^3^,*	|	anwar786kp@hotmail.com |
|Muhammad Tahir Khan^4^ |	muhammad.tahir8@imbb.uol.edu.pk |
|Sajid Ali^2^ | sajidjan@live.com |
|Muhammad Qasim^2^ | qasim@kust.edu.pk |

XXXXX Aga Khan group XXXX	

| | |
| ----------- | ----------- |
|Susana Campino^1^ | susana.campino@lshtm.ac.uk |
|Sajjad Ahmad^5^ | sajjadahmad793@yahoo.com |
|Hazir Rahman^6^ | hazirrahman@hotmail.com |
|Taj Ali Khan^5^,** | tajalikhan.ibms@kmu.edu.pk |
|Jody E. Phelan^1^,** | jody.phelan@lshtm.ac.uk |
|Taane G. Clark^1^,^7^,** | taane.clark@lshtm.ac.uk |

XXX to be confirmed XXX

^1^ Faculty of Infectious & Tropical Diseases, London School of Hygiene & Tropical Medicine, London, UK \
^2^ Department of Microbiology, Kohat University of Science and Technology, Kohat, Pakistan; \
^3^ Provincial Tuberculosis Reference, Laboratory Hayatabad Medical Complex, Peshawar, Pakistan; \
^4^ Institute of Molecular Biology and Biotechnology (IMBB), The University of Lahore. KM, Defense Road, Lahore 58810, Pakistan \
^5^ Institute of Basic medical Science Khyber Medical University, Peshawar KP, Pakistan \
^6^ Department of Microbiology, Abdul Wali Khan University, Mardan, Pakistan \
^7^ Faculty of Epidemiology and Population Health, London School of Hygiene & Tropical Medicine, London, UK \


\* Joint authors \
\*\* Joint Correspondence: \
Prof. Taane G. Clark, London School of Hygiene & Tropical Medicine, UK; taane.clark@lshtm.ac.uk
Dr. Jody Phelan, London School of Hygiene & Tropical Medicine, UK; jody.phelan@lshtm.ac.uk
Dr. Taj ali Khan, Institute of Basic medical Science Khyber Medical University Peshawar KP Pakistan; tajalikhan.ibms@kmu.edu.pk


## ABSTRACT



## INTRODUCTION

Tuberculosis disease (TB), caused by bacteria in the Mycobacterium tuberculosis (Mtb) complex, is a major global public health problem. Pakistan is a high-burden TB country, being one of eight countries accounting for two-thirds of the global total TB instance (5.7%). In 2019 it had a  total TB incidence of 570,000 and 43,900 deaths [@WHO_2020]. Furthermore, HIV prevalence in the country is increasing (0.1 prevalence 2019), which compounds the problem of TB infections and treatment [@UNAIDS_2020] (5,100 cases and 1,900 HIV-positive mortality cases in 2019). There is also a high burden for rifampacin resistant (RR-TB) and multidrug-resistance (MDR-TB, resistance to isoniazid and rifampicin treatments), with 25,000 cases of MDR/RR-TB in the latest WHO estimates. 

Whole genome sequencing is revolutionizing our understanding of drug resistance and clinical management, as well as transmission patterns, thereby can assist disease control. Within such a context, it is crucial to monitor transmission patterns and ensure that patients are being treated with optimal drug regimens. Here, we analyse `r n_samps_total` whole genome sequences (WGS) of Pakistan *Mycobacterium tuberculosis* (*Mtb*) samples dating from `r round(first_year)` to `r round(last_year)`, using `r fmt(n_snps_total)` SNPs to infer a timed phylogenetic tree and to predict resistance to `r n_drugs_total` drugs. While our data included phenotypic tests of resistance for `r n_pheno_tests` drugs (`r pheno_test_names`), we also applied genotypic tests of drug resistance using TBprofiler [@Coll2015] to predict drug resistance from a database of ~34,000 WGS samples. The `r n_samps_total` samples were previously published between `r min(pub_years)` and `r max(pub_years)` in `r as.english(length(unique(metadata$study_name)))` different studies. 

Drug resistance and its associated mutation have previously been characterised in samples from Pakistan. Ali (2015) [@Ali2015] investigated XDR isolates across four provinces, and consistent with the present study, most samples (67%) belonged to the Central Asian Strain (CAS) family (lineage 3). Here, SNP mutations were found to be associated to resistance to rifampicin (*rpoB*), isoniazid (*katG* and *inhA*), pyrazinamide (*pncA*), fluoroquinolones (*gyrA*) and aminoglycosides (*rss*). Leading on from this study, Kanji (2017) [@Kanji2017] found increased frequency and expression of novel SNP mutations in efflux pump genes, potentially explaining drug resistance mechanisms. 

Further novel drug-resistance associated mutations were investigated in Jabbar (2019) [@Jabbar2019] in samples from the Khyber Pakhtunkhwa province for 11 anti-TB drugs. Again, the moajority of samples (76.5%) were CAS (lineage 3) samples. Previously unknown mutations were found for ethionamide (*katG* and *ethA*), fluoroquinolones (*gyrA* and *gyrB*) and pyrazinamide (*pncA*). This study also provided evidence of transmission chains in North-West Pakistan: With a standard 10-SNP difference cut-off, there were eight potential transmission clusters formed of 18 drug-resistant samples, concluding that there was support for spread of MDR TB. 

Recently, Qadir (2021) [@Qadir2021] confirmed mutations in the Rifampacin Resistance Determining Region (RRDR) of the *rpoB* gene among 702 Pakistan isolates, and discovered three novel mutations. 


<!--
---

"Characterizing Mycobacterium tuberculosis isolates from Karachi, Pakistan: drug resistance and genotypes"
sciencedirect.com/science/article/pii/S1201971212000276
[@Ayaz2012]

- Resistance rates – new and previously treated:
- MDR-TB: 2.4% and 13.9%
- RIF monoresistance, 0.1% and 0.6%
- Any INH resistance, 8.9% and 28.5%
- INH monoresistance, 3.0% and 6.3%

- Risk factors:
- Prior TB treatment - MDR-TB and INH monoresistance
- Low socioeconomic status - INH monoresistance
- Balouchi, Sindhi or Pakhtun ethnicity for MDR-TB.
- Central Asian strain (55.6%) was the most prevalent genotype
- MDR-TB was significantly associated with Haarlem (H) genogroup

- Conclusions
- An MDR-TB rate of 2.4% is reported in new patients. 
- Low RIF monoresistance supports the use of RIF as a marker for MDR-TB in this population.
- The need to strengthen TB care in the identified at-risk groups is emphasized.
- Based on INH resistance rates, a review of national treatment/prevention regimens relying on INH is suggested.

---

Lit rev:

"Whole Genome Sequencing Based Characterization of Extensively Drug-Resistant Mycobacterium tuberculosis Isolates from Pakistan"
https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0117771#sec002
[@Ali2015]

- Investigated 40 genes associated with drug resistance
- Rifampicin resistance was attributable to SNPs in the rpoB hot-spot region
- Isoniazid resistance was most commonly associated with the katG codon 315 (92%) mutation followed by inhA S94A (8%) 
- However, one strain did not have SNPs in katG, inhA or oxyR-ahpC
- All strains were pyrazimamide resistant but only 43% had pncA SNPs
- Ethambutol resistant strains predominantly had embB codon 306 (62%) mutations, but additional SNPs at embB codons 406, 378 and 328 were also present
- Fluoroquinolone resistance was associated with gyrA 91–94 codons in 81% of strains; four strains had only gyrB mutations, while others did not have SNPs in either gyrA or gyrB
- Streptomycin resistant strains had mutations in ribosomal RNA genes; rpsL codon 43 (42%); rrs 500 region (16%), and gidB (34%) while six strains did not have mutations in any of these genes.
- Amikacin/kanamycin/capreomycin resistance was associated with SNPs in rrs at nt1401 (78%) and nt1484 (3%), except in seven (19%) strains.
- We estimate that if only the common hot-spot region targets of current commercial assays were used, the concordance between phenotypic and genotypic testing for these XDR strains would vary between rifampicin (100%), isoniazid (92%), flouroquinolones (81%), aminoglycoside (78%) and ethambutol (62%); while pncA sequencing would provide genotypic resistance in less than half the isolates. 
- This work highlights the importance of expanded targets for drug resistance detection in MTB isolates.

---

"Single nucleotide polymorphisms in efflux pumps genes in extensively drug resistant Mycobacterium tuberculosis isolates from Pakistan"
https://www.sciencedirect.com/science/article/pii/S1472979216305534?via%3Dihub
[@Kanji2017]

- WGS analysis of 37 XDR and five drug sensitive (DS) MTB isolates
- SNPs in efflux pump genes Rv0194, Rv1217, Rv1218, drrA, drrB, Rv1258, Rv1634, Rv2688, Rv1273, Rv1819, Rv1458, Rv1877 and Rv1250 were determined in the isolate compared with H37Rv
- Frequencies of SNPs identified in XDR strains were compared with DS strains. 
- Gene expression of Rv0194, Rv2688, Rv1634, drrA and drrB was determined in XDR -TB isolates (n=9), DS-TB strains (n=4) and H37Rv.

- We identified SNPs in XDR-TB isolates which were either unique or present at very low frequencies in DS strains; Rv0194 G170V; Rv1217 L151R; Rv1258 P369T and G391R; Rv1273 S118G and I175T; Rv1877 I534T; Rv1250 V318X/A and S333A, and Rv2688 P156T. 
- The expression of Rv2688 and drrB was found to be raised in XDR-TB as compared with DS-TB strains.

- We identified unique SNPs in efflux pump genes which may be associated with increased drug resistance in the isolates. 
- Increased levels of Rv2688 and drrB efflux pump gene expression observed in XDR strains even in the absence of antibiotics suggests that these clinical isolates may be more refractory to treatment.
- Further studies are required to directly associate these mutations with increased resistance in MTB.

---

"Whole genome sequencing of drug resistant Mycobacterium tuberculosis isolates from a high burden tuberculosis region of North West Pakistan"
https://www.nature.com/articles/s41598-019-51562-6
[@Jabbar2019]

- Khyber Pakhtunkhwa province (North West Pakistan), n = 81
- WGS & DST 
- 11 anti-TB drugs. 
- majority CAS/Delhi strain-type (lineage 3; 70.4%) 
- MDR 76.5%)
- Most freq: katG / rpoB - isoniazid / rifampicin
- pncA (pyrazinamide), embB (ethambutol), gyrA (fluoroquinolones), rrs (aminoglycosides), rpsL, rrs and giB (streptomycin) 
- Describe unreported markers: katG, ethA (ethionamide), gyrA and gyrB (fluoroquinolones), and pncA. 
- Analysis of the mutations: acquisition of rifampicin resistance often preceded isoniazid in our isolates.
- High proportion (17.6%) of pre-MDR isolates with fluoroquinolone resistance markers, potentially due to unregulated anti-TB drug use. 
- Our isolates were compared to previously sequenced strains from Pakistan in a combined phylogenetic tree analysis. 
- The presence of lineage 2 was only observed in our isolates. 
- Using a cut-off of less than 10 SNP diffs, a transmission analysis revealed 18 isolates clustering within eight networks, thereby providing evidence of drug-resistant TB transmission in the Khyber Pakhtunkhwa province. 
- Overall: DR TB isolates are circulating and transmitted in North West Pakistan. 
- Further, we have shown the usefulness of whole genome sequencing as a diagnostic tool for characterizing M. tuberculosis isolates, which will assist future epidemiological studies and disease control activities in Pakistan.

---

"Insight into the drug resistance whole genome of Mycobacterium tuberculosis isolates from Khyber Pakhtunkhwa, Pakistan"
https://www.sciencedirect.com/science/article/abs/pii/S1567134821001581
[@Khan2021]

- Aimed to find genomic variations in the first-line drugs targets, along with other virulence and evolutionary factors among the circulating isolates in Khyber Pakhtunkhwa, Pakistan. 
- Some novel mutations have been detected in drugs targets. 
- Similarly, numerous novel variants have also been detected in virulency and evolutionary factors, PE, PPE, and secretory system of MTB isolates. 

---

"Profiling and identification of novel rpoB mutations in rifampicin-resistant Mycobacterium tuberculosis clinical isolates from Pakistan"
https://pubmed.ncbi.nlm.nih.gov/34244055/
[Qadir2021]

RIF resistance has been linked with mutations in rpoB gene. 

- 322 phenotypically RIF-resistant isolates were randomly selected from National TB Reference Laboratory, Pakistan for sequencing 
- while 380 RIF resistance whole-genome sequencing (WGS) of Pakistani isolates (BioProject PRJEB25972), were also analyzed for rpoB mutations.

- 96.1% isolates harbored mutations in rpoB 
- 94.4%) were detected within the RRDR, including three novel. 

Among these mutations, 657 (97.3%) were substitutions including 603 (89.3%) single nucleotide polymorphism, 49 (7.25%) double and five (0.8%) triple. About 94.4% of Phenotypic RIF resistance strains, exhibited mutations in RRDR, which were also detectable by GeneXpert.

Conclusion: Mutations in the RRDR region of rpoB is a major mechanism of RIF resistance in MTB circulating isolates in Pakistan. Molecular detection of drug resistance is a faster and better approach than phenotypic drug susceptibility testing to reduce the time for transmission of RIF resistance strains in population. Such insights will inform the deployment of anti-TB drug regimens and disease control tools and strategies in high burden settings, such as Pakistan.

-->



## RESULTS

### Clinical isolates and phylogeny

A total of `r n_samps_total` *M. tuberculosis* WGS isolates from Pakistan were downloaded from the European Nucleotide Archive (ENA). The samples were cultured, whole-genome sequenced, and drug susceptibility testing (DST) was applied for `r n_pheno_tests` drugs. These isolates covered four provinces, but a high proportion of locations were missing (69.5%), all from one study [@Cryptic2018] (Table 1). Combining the results of the DST and the genotypic prediction tests (see **Methods**), `r n_sens` (`r pc_sens`%) samples were pan-sensitive, `r n_mdr` (`r pc_mdr`%) classed as MDR-TB (resistant to both rifampicin and isoniazid), and `r n_xdr` (`r pc_xdr`%) were XDR (resistant to isoniazid and rifampicin, plus any fluoroquinolone and at least one of three injectable second-line drugs). See **Table \@ref(tab:drTableLin)** for Pre-MDR, Pre-XDR figures and drug resistance categories by lineage. 


```{r dst-stats, echo=F}

n_rif_dst <- dr_tab_easy[dr_tab_easy[, "drug"] == "rifampicin", "N_dst_total"]
pc_rif_dst_tested <- (n_rif_dst/n_samps_total)*100

n_izd_dst <- dr_tab_easy[dr_tab_easy[, "drug"] == "isoniazid", "N_dst_total"]
pc_izd_dst_tested <- (n_izd_dst/n_samps_total)*100

n_eth_dst <- dr_tab_easy[dr_tab_easy[, "drug"] == "ethambutol", "N_dst_total"]
pc_eth_dst <- (n_eth_dst/n_samps_total)*100

n_pzd_dst <- dr_tab_easy[dr_tab_easy[, "drug"] == "pyrazinamide", "N_dst_total"]
pc_pzd_dst <- (n_pzd_dst/n_samps_total)*100


n_drugs_no_dst <- sum(dr_tab_easy[, "N_dst_total"] == 0 | is.na(dr_tab_easy[, "N_dst_total"]))

```

Phenotypic drug susceptibility testing (DST) was most complete for rifampicin (n=`r n_rif_dst`, `r pc_rif_dst_tested`%), isoniazid (n=`r n_izd_dst`, `r pc_izd_dst_tested`%), ethambutol (n=`r n_eth_dst`, `r pc_eth_dst`%), and pyrazinamide (n=`r n_pzd_dst`, `r pc_pzd_dst`%) drugs (S2 Table), but incomplete / not present for `r n_drugs_no_dst` drugs. 

Historically, *Mtb* samples from Pakistan belong predominantly to the CAS1-Delhi spoligotype family [@Demay2012], which belongs to Lineage 3 [@Napier2020]. In our samples, Lineage 3 comprises `r lin_tab[lin_tab["Lineages"] == 3, "pc"]`% of the total samples, followed by Lineage 4 (n=`r n_lin_4`, `r pc_lin_4`%), Lineage 2 (n=`r n_lin_2`, `r pc_lin_2`%) and Lineage 1 (n=`r n_lin_1`, `r pc_lin_1`%) (see **Table \@ref(tab:lintable)** for a breakdown of samples by lineage and sublineage and see **Figure \@ref(fig:ggtree-all-samps)** for a full phylogenetic tree). 

After sequence data alignment, high average coverage was observed across the samples (median 76, range 30-2,027). 

### Evidence of transmission

Median (range) pairwise SNP distances was `r round(median(lower_dist), rnd)` (min=`r min(lower_dist)`, max=`r max(lower_dist)`) for all `r n_samps_total` samples. 

With a threshold of `r threshold` SNPs, `r n_clusters_cut_tree` clusters formed, where the median cluster size was `r med_clust_threshold` (range: `r min_clust_threshold`-`r max_clust_threshold`). **Figure \@ref(fig:distanceqgraph)** shows a graph of SNP distance connections among these samples (n = `r length(attributes(dist_thresh)$Labels)`). 

<!--
Chi-square tests for proportions of samples within the `r threshold`-SNP distance threshold for lineage, drug resistance status and location were all significant (X-sq=`r trans_lin_chi_sq$statistic`, p=`r scientific(trans_lin_chi_sq$p.value, digits = 2)`, X-sq=`r trans_dr_chi_sq$statistic`, p=`r scientific(trans_dr_chi_sq$p.value, digits = 2)`, X-sq=`r trans_loc_chi_sq$statistic`, p=`r scientific(trans_loc_chi_sq$p.value, digits = 2)`, respectively). **Figure \@ref(fig:trans-category-plots)** shows that lineages 2 and 4 have significantly more samples within `r threshold` SNPs than expected, as did Pre-XDR and XDR samples. Among locations, Peshawar showed a much higher proportion of potential transmission samples than expected.
-->


Comparing the 169 "transmitted" isolates in clusters to the others ("non-transmitted"; n=366), there was an increased risk of transmission in lineages 2 and 4 (overall chi-sq=`r trans_lin_chi_sq$statistic`, p=`r scientific(trans_lin_chi_sq$p.value, digits = 2)`; post-hoc tests: lineage 2 standardised residual=3.57, p=0.003; lineage 4 standardised residual=4.62, p=0.00003), Pre-XDR and XDR samples (overall chi-sq=98, p=0.0005; post-hoc tests: Pre-XDR standardised residual=5.31, p=<0.0001; XDR standardised residual=6.55, p=<0.0001), and in Peshawar province (overall chi-sq=70, p=0.0005; post-hoc tests: Peshawar standardised residual=5.74, p=<0.0001) (S5 Table; S3 Figure; S4 Figure). 


**Figure \@ref(fig:n-clusters-plot)** and **Table \@ref(tab:dist-sens-table)** show a sensitivity analysis of different SNP-distance thresholds. 


<!--
Date of collection was recorded between the years `r first_year` and `r last_year` (`r last_year - first_year` years) for `r n_dated_samps` samples, which represent probable closely-related, if not potiential transmission cases. A dated phylogenetic tree was constructed with these samples (**Figures \@ref(fig:beasttrees)**), and when cut at `r cutoff_year` years before the last sample date, `r n_beast_clusters` clusters (n=`r n_beast_cluster_samps`) were inferred. 
-->


### Drug susceptibility discrepancies

We identified DSTs that disagreed with the genotypic drug resistance predictions for all samples (n=`r n_samps_total`). These discrepancies were classified into two kinds - where the phenotypic test showed resistance and the genotypic test predicted sensitivity ("false negative" (FN)), and where the phenotypic test result was sensitive but the genotypic test predicted resistance ("false positive" (FP)). Within the clusters defined above, `r n_FN_samps` samples were FN for `r as.english(n_FN_drugs)` drugs (`r FN_drugs`) and `r n_FP_samps` samples were FP for `r as.english(n_FP_drugs)` drugs (`r FP_drugs`).

For phenotypic DST, there were `r n_samps_dst_res` total samples (`r (n_samps_dst_res/n_samps_total)*100`%) resistant to at least one drug (median = `r median(dst_by_row_vect)`, max = `r max(dst_by_row_vect)`). 

```{r echo = F}

max_FP_drug <- names(which.max(FP_res))
max_FP_drug <- gsub("_.*", "", max_FP_drug)
max_FP_val <- FP_res[which.max(FP_res)]

```

The number of potential errors on the phenotypic testing appeared low (`r total_FP`/`r total_dst_tests` tests), where established genotypic resistance markers were present in isolates with DST results that implied sensitive. The discordance appeared in `r n_FP_drugs` drugs (`r FP_drugs`), but predominantly in `r max_FP_drug` (`r max_FP_val`) (S2 Table). 

Among the phenotypic DST results, a high percentage were resistant to four drugs: rifampicin (n=`r dr_tab_easy[dr_tab_easy$drug == "rifampicin", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "rifampicin", "pc_dst"]`%), isoniazid (n=`r dr_tab_easy[dr_tab_easy$drug == "isoniazid", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "isoniazid", "pc_dst"]`%), ethambutol (n=`r dr_tab_easy[dr_tab_easy$drug == "ethambutol", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "ethambutol", "pc_dst"]`%), and pyrazinamide (n=`r dr_tab_easy[dr_tab_easy$drug == "pyrazinamide", "N_dst"]`, `r dr_tab_easy[dr_tab_easy$drug == "pyrazinamide", "pc_dst"]`%)

Known drug-resistance mutations were predicted in TB-profiler [@Phelan2019] and compared to the phenotypic DST results for `r n_tbp_drug_tests` distinct drugs (plus fluoroquinolones and aminoglycosides generically). We identified a total of `r sum(discrepancy_data == FP | discrepancy_data == FN)` individual DSTs that disagreed with the genotypic drug resistance predictions in `r n_FN_samps+n_FP_samps` samples (**Table \@ref(tab:dr-tab)**; the other discrepancies here are explained by the unavailability of phenotypic DST data). Of these samples, `r n_FN_samps` were FN, and `r n_FP_samps` samples FP.


### Mutations potentially exlpaining drug-resistance

For FN samples, **Table \@ref(tab:FNresultstable)** shows all variants found in drug resistance-associated genes for `r n_FN_drugs` drugs (`r FN_drugs`), that were previously unknown to be associated with each respective drug, potentially explaining discrepancies between phenotypic DST results and genotypic predictions. 

#### Rifampicin
Three different inframe indels (c.1291_1292insGCC, c.1294_1296del and c.1309_1311del) were found in three isolates with no other known resistance mutations. 

#### Isoniazid
Several nonsense mutations in *katG* were found to explain discrepant results between genotype and DST for isoniazid. These include three mutations leading to premature stop codons (p.Trp438\*, p.Trp204\*, p.Gln36\*) and a frameshift mutation (c.587_588insGGT). 

#### Ethambutol
Variants in the *embA* promoter region and *embB* were observed in isolates with resistant DSTs but no known resistance mutations. Four isolates contained mutations in the *embA* promoter region including two deletions (c.-42CAT>C, c.-27TA>T) and two SNPs (c.-16C>A, c.-8C>A). 

#### Second line injectables
The mutation r.878g>a was found in *rrs* and was previously reported by Malinga *et al* [@Malinga2016] as well as Jabbar *et al* [@Jabbar2019] (of which the samples are present in the currently analysed set). Malinga *et al* report the mutation to be involved with capreomycin resistance and to be associated with the EuroAmerican X3 strain. We observe the mutation in four lineage 3 strains with three independent homoplastic acquisitions, signifying the mutation is not limited to EuroAmerican X3 strains. Mutations in *rrs* are generally clustered in two regions with the most common mutations involved with streptomycin resistance being located around position 514 and those involved with resistance to amikacin, kanamycin and capreomycin located around 1401. As this mutation is located in between these two mutation hotspots, it is yet to be determined to which drug it confers resistance. Of the three strains which had DST data (amikacin and kanamycin) in this study, two were resistant to both amikacin and kanamycin and the other was sensitive to both. 

#### Pyrazinamide
Mutations in *pncA* were present in isolates for which no known resistance variants could be found. These include three inframe indels (c.511_512insTCGCCG, c.392_393insGGT and c.451_462del) a premature stop codon (p.Ser18\*), and SNPs in both the coding region (p.Val180Ala) and the promoter (c.-7T>G). 

#### Streptomycin
Several mutations in *gid* were found in DST-discrepant isolates. These include nonsense mutations leading to a premature stop codon (p.Gly71\*) and frameshift (c.102_102del). Low-level streptomycin resistance has been shown to be conferred through loss-of-function mutations in *gid*. SNPs were also found in isolates (p.Ala119Asp, p.Ala82Pro and p.Asp67Gly). These SNPs were not found to be previously reported, however they were found in the global dataset. All mutations were found to have been acquired as the result of homoplasy. The p.Ala119Asp mutation was present in 15 isolates (ten different sublineages), of which two had DSTs and were resistant. The p.Ala82Pro mutation was present in three isolates from two different sublineages. No DST was available for these isolates. The p.Asp67Gly was present in 38 global isolates from five different sublineages. Of these, seven had DST data available with four presenting resistance. 

#### Fluoroquinolones
The p.Ala288Asp mutation in *gyrA* was found in three lineage 3 isolates and was acquired in each sample independently. One isolate was tested resistant to ciprofloxacin with no known resistance mutation found in the *gyrA* and *gyrB* genes. This mutation was previously reported by Farhat *et al* [@Farhat2016], with the mutation leading to an observed increase in MIC to both ofloxacin and moxifloxacin.

## DISCUSSION

This study helps demonstrate the value of WGS in the context of a low-income, high-burden country. Our findings on potential transmission among lineages 2 and 4, Pre-XDR and XDR TB, and in Peshawar, as well as drug resistance mutations can inform better epidemiological, clinical, and control decisions in Pakistan and, more generally, provides insight into mutations relevant to drug design. WGS can potentially be particularly useful in countries similar to Pakistan where effective public health surveillance is inadequate due to socio-economic problems - genetic data can fill gaps in data collection, revealing salient connections and variation.

### Transmission

Evidence of increased transmission among lineages 2 and 4 is consistent with previous characterisations of these clades as more transmissible [@Coscolla2014a][@Assuncao2015], and therefore ought to be monitored more closely despite greater prevalence of lineage 3. 

It is surprising that Pr-XDR and XDR samples were found to be clustered more than expected given the usual fitness cost of drug resistance [@Cohen2003][@Gygli2017]. This however suggests unknown compensatory mutations and ought to be investigated in future work. 

### Drug resistance

Inframe deletions have not been widely reported as a major mechanism of resistance to rifampicin and it is surprising to see the relative high number of these mutations in our dataset.

Nonsense mutations are presumed to lead loss of function in the *katG* gene since it codes for the activator of isoniazid (catalase-peroxidase enzyme), so it is unsurprising to see potentially drug-resistance conferring mutations here. 

Mutations in the -16 and -8 position of the *embA* promoter have been reported to enhance binding of the *embR* transcription regulator to the promoter and increase expression of *embCAB* operon. The deletions are also presumed to have a similar effect to enhance binding of *embR*, though further experimental evidence would be required in future. 

The two strains which were resistant to both amikacin and kanamycin also contained a mutation in the promoter region to *eis* (c.-14C>T). This mutation could potentially explain the resistance to both these drugs and may point to the r.878g>a being either increasing the level of resistance to these drugs or potentially conferring resistance to streptomycin (which was not tested for in these samples).

The *pncA* gene codes for the activator of pyrazinamide and loss of function leads to resistance. The functional consequence of the premature stop codons and indels are usually severe to protein function and these mutations in our isolates represent highly likely candidates as conferring resistance. Mutations in the promoter region of *pncA* leads to changes in the expression of PncA and resistance [@Sheen2013]. The c.-7T>G mutation is thus also likely to cause resistance. The functional effect of SNPs in the coding region of *pncA* can be harder to predict, however the Val180Ala mutation was reported previously to be associated to pyrazinamide resistance in the CARD database [@Alcock2020].

The incomplete penetrance of the streptomycin-associated p.Asp67Gly mutation could be explained by the relative low-level resistance conferred by mutation in *gid* which could be under the critical concentration but still elevated with respect to wild-type.

## METHODS

<!--
```{r methods, echo=FALSE, out.width = "1500px"}

kable(methods_table)

```
-->

### Sequence data and processing

WGS were sourced across `r as.english(length(unique(metadata$study_name)))` studies [@Stucki2016] [@Phelan2016a] [@Cryptic2018] [@Coll2018][@Jabbar2019][@Khan2021](ENA accessions: PRJEB7798, PRJEB10385, PRJEB25972, PRJEB32684, PRJEB43284). 

Sequences were downloaded from the European Nucleotide Archive (ENA www.ebi.ac.uk/ena/) and quality inspection of reads assessed in fastQC (version 0.11.9, www.bioinformatics.babraham.ac.uk/projects/fastqc/). Raw reads were trimmed to remove low-quality sequences in Trimmomatic v0.39 [@Bolger2014] and aligned to the H37Rv reference genome (AL123456) with BWA mem v0.7.17 [@Li2013], [@Cole1998]. 

Joint SNP calling was processed in gatk GenotypeGVCFs v4.1.3.0 [@Depristo2011]. SNP filtering excluded indels, heterozygous SNPs, monomorphic SNPs and non-unique regions of the genome (e.g. PE/PPE genes), which was conducted in bcftools v1.9 [@Li2009]. 

A multi-FASTA format file was created from the filtered SNP file and H37Rv reference fasta using bedtools makewindows v2.28.0 [@Quinlan2010] which in turn was used to construct a phylogenetic tree with IQ-TREE v1.6.12. Here, a general time reversible model with rate heterogeneity set to a discrete Gamma model and an ascertainment bias correction were used (parameters -m GTR+G+ASC), with 1000 bootstrap samples used to measure branch quality and robustness. [@Nguyen2015] [@Hoang2018] [@Tavare1986] [@Lewis2001] [@Yang1994].

Pairwise distance matrices were calculated in Plink v1.90b4 [@Purcell2007]. Drug resistance status, drug resistance-associated mutations, other mutations, and lineages were predicted *in silico* using TB-Profiler v2.4 [@Phelan2019] [@Coll2015] [@Napier2020]. In categorising samples as *Susceptible*, *Pre-MDR*, *MDR*, *Pre-XDR*, *XDR*, or *other*, the TB-Profiler predictions were used in place of missing or contradictory DST data. 

Linear mixed models have been previously applied to adjust for the confounds of *Mtb* (sub-)lineage and outbreak-based population structure [@Phelan2016b].Therefore a linear mixed regression model was conducted to estimate the strength of association between the binary "transmission"/"non-transmission" outcome and SNPs, conducted in GEMMA (v.1.1.2) [@Zhou2012].




<!--

BEAST v2.6.3 [@Bouckaert2019] was used to infer timed phylogenetic trees (see **Table \@ref(tab:beautiparams)** for parameters and settings). From the high ESS values (**Table \@ref(tab:beastlogtable)**) and the non-directional trace plots in (**Figure \@ref(fig:beastlogplots)**), effective sample size seems satisfactory and parameters have converged.

-->

***

### Tables

#### General
```{r table-1, echo=FALSE, out.width = "2000px"}

knitr::kable(table_1, row.names = NA, rownames.print = F, caption = sprintf("*Mycobacterium tuberculosis* samples (N = %s)", n_samps_total))

```
***
#### Lineages
```{r lintable, echo=FALSE, out.width = "2000px"}

# knitr::kable(lin_tab, align = align)
# cap <- "Table of main sublineages as proposed by Comas et al (2010) [@Comas2010] and Stucki et al (2016) [@Stucki2016] and predicted by Napier (2020) [@Napier2020], and their equivalents in 'Large Sequence Polymorphism' lineages[@GagneuxDeRiemer2006] and spoligotype families[@Demay2012]."
cap <- "Strain-types"
knitr::kable(lin_conv_tab, caption = cap)

```
***
#### Transmission
```{r in-trans-table, echo=FALSE, out.width = "2000px"}

# knitr::kable(in_trans_df,
#              caption = sprintf("Lineages, drug-resistance status and locations of samples 'in transmission' - i.e. a SNP distance of %s (n=%s)", threshold, length(clusters)))

knitr::kable(trans_df,
             caption = sprintf("Lineages, drug-resistance status and locations of samples 'in transmission' - i.e. a SNP distance of %s (n=%s)", threshold, length(clusters)))

```
***
```{r dist-sens-table, echo=FALSE, out.width = "2000px"}

knitr::kable(dist_sensitivity_table, caption = "Sensitivity analysis of clustering by SNP distance, summary statistics")

```
***
#### Drug resistance
```{r drTableLin, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_lin_tab, row.names = NA, rownames.print = F, caption = "Drug resistance categories by lineage. See *Methods* section for criteria of categories.")

```
***
```{r dr-tab, echo=FALSE, out.width = "2000px"}

knitr::kable(dr_tab, caption = "Numbers and percentages of drug-resistant samples accourding to DST and genotypic predictions (TBprofiler)")

```
***
```{r dr-variants-table, echo=FALSE, out.width = "2500px"}

knitr::kable(dr_variants_pivot, 
             caption = sprintf("Number of samples with known drug resistance-associated mutations by gene and drug (n=%s)", n_samps_total))

```
***
```{r FNresultstable, echo=FALSE, out.width = "2500px"}

knitr::kable(FN_results_table_pivot, caption = sprintf("Number of samples with variants previously unknown to be associated with drug resistance (for each respective drug) among 'FN' drug susceptibility test samples (n=%s)", n_FN_samps) )

```
***

<!--
#### Beast
```{r beautiparams, echo=FALSE, out.width = "2000px"}

knitr::kable(beauti_params, caption = "Settings in Beauti for BEAST analysis. Parameters & priors are based on Xu (2020) [@Xu2020]")

```
***
```{r beastlogtable, echo=FALSE, out.width = "1500px"}

# Results of beast log

# Remove the burn-in
beast_log <- tracerer::remove_burn_ins(
  beast_log,
  burn_in_fraction = 0.1
)

# Calculates the effective sample sizes of all parameter estimates
esses <- t(tracerer::calc_esses(beast_log, sample_interval = 1000))

# Get means
means <- apply(beast_log, 2, mean)
means <- means[!(names(means) %in% "Sample")]

# Combine
log_table <- cbind(means, esses)
colnames(log_table) <- c("Mean", "ESS")
log_table <- round(log_table, 2)

knitr::kable(log_table, caption = "Mean and effective sample size (ESS) outputs from BEAST for tree parameter posteriors.")

```
***
-->

### Figures

<!--
```{r historical, fig.cap = sprintf("Number of samples by spoligotype family \n in historical Mtb data from Pakistan [@Demay2012], n = %s", n_samps_historical) , echo=FALSE, out.width = "2000px"} 

n_samps_historical <- length(historical_metadata$IsoNumber)

barplot(table(historical_metadata$Clade), las=2, main = "", col = col, cex.axis = 0.5, cex.names=0.75)

```
-->
<!--
```{r treeAllSamps, echo=FALSE, out.width = "2000px", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total)) }

cap <- sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))

knitr::include_graphics(tree_all_samps_file)

```
-->

***

```{r ggtree-setup, echo = F}


# GGTREE SETUP ----


# Prep data for heatmaps (strips)

legend_spec <- theme(legend.title = element_text(size = 9),
                     legend.text = element_text(size = 7),
                     legend.key.size = unit(0.3, "cm"))

# Add id/year hybrid col
metadata$id_year <- paste0(metadata$wgs_id, "_", metadata$year)
rownames(metadata) <- metadata$id_year
# heatmap_data <- metadata[metadata$id_year %in% mcc_tree_ape$tip.label,
#                          c("main_lineage", "dr_status"), drop = F]
# Subset metadata
lin_data <- metadata[, "main_lineage", drop = F]
dr_status_data <- metadata[, "dr_status", drop = F]
loc_data <- metadata[, "location_other", drop = F]
dr_data <- dplyr::select(metadata, rifampicin:delamanid)
dr_tbp_data <- dplyr::select(metadata, rifampicin_tbp:delamanid_tbp)
drug_discrepancy_data <- dplyr::select(metadata, rifampicin_test:delamanid_test)

# Clean location data
# loc_data[loc_data == ""] <- NA

# Clean dr_tbp_data
dr_tbp_data[dr_tbp_data != "-"] <- 1
dr_tbp_data[dr_tbp_data == "-"] <- 0

# Convert lin and DR data to factors
dr_data <- data.frame(apply(dr_data, 2, as.factor))
dr_tbp_data <- data.frame(apply(dr_tbp_data, 2, as.factor))
lin_data <- data.frame(apply(lin_data, 2, as.factor))
# drug_discrepancy_data <- data.frame(apply(drug_discrepancy_data, 2, as.factor))

# Change col names
colnames(dr_status_data) <- "DR status"
colnames(lin_data) <- "Lineage"
colnames(loc_data) <- "Location"
colnames(dr_data)[colnames(dr_data) %in% "para_aminosalicylic_acid"] <- "PAS"
colnames(dr_tbp_data) <- gsub("_tbp", "", colnames(dr_tbp_data))
colnames(dr_tbp_data)[colnames(dr_tbp_data) %in% "para_aminosalicylic_acid"] <- "PAS"
colnames(drug_discrepancy_data) <- gsub("_test", "", colnames(drug_discrepancy_data))
colnames(drug_discrepancy_data)[colnames(drug_discrepancy_data) %in% "para_aminosalicylic_acid"] <- "PAS"


# Define cols for each dataset
alpha <- 0.9
lin_colours <- rainbow(length(unique(metadata$main_lineage)), alpha = alpha)
dr_status_colours <- scales::alpha(gplots::col2hex(c("green1", "yellow2", "orange1", "red1", "black", "grey")), alpha = alpha)


# n <- length(unique(loc_data$Location))

# qual_col_pals <- brewer.pal.info[brewer.pal.info$category == 'qual',]
# col_vector <- unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
# set.seed(2)
# loc_cols <- sample(col_vector, n)

loc_cols <- c(brewer.pal(9,"Set1"), "#FFFFFF")
names(loc_cols) <- sort(unique(loc_data$Location))

# Save missing col
missing_col <- loc_cols[names(loc_cols) %in% "Missing"] 

# Make missing white
loc_cols[names(loc_cols) %in% "Missing"] <- loc_cols[length(loc_cols)]

# Make the last loc the previous missing colour
loc_cols[length(loc_cols)] <- missing_col

# loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
# loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

# loc_cols <- randomcoloR::distinctColorPalette(length(unique(loc_data$Location)))
# names(loc_cols) <- unique(loc_data$Location)
# loc_cols[is.na(names(loc_cols))] <- "#FFFFFF"
# loc_cols <- c(loc_cols[sort(names(loc_cols))], loc_cols[is.na(names(loc_cols))])

drug_discrepancy_vals <- sort(unique(as.vector(as.matrix(drug_discrepancy_data))))
drug_discrepancy_cols <- brewer.pal(length(drug_discrepancy_vals), "Paired")

# Add names (unique vals for each dataset) to dataframes. Don't need to do this for the binary data (DR individual status)
names(lin_colours) <- c(sort(unique(metadata$main_lineage)))
names(dr_status_colours) <- c("Sensitive", "Pre-MDR", "MDR", "Pre-XDR", "XDR", "Other")
names(drug_discrepancy_cols) <- drug_discrepancy_vals

```


```{r ggtree-all-samps, echo=FALSE, out.width = "1500px", dpi = 300, fig.height=5, warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The %s *M. tuberculosis* isolates: A phylogenetic tree constructed using %s SNPs", n_samps_total, fmt(n_snps_total))}

# Tree setup
line_sz <- 0.25
n <- length(tree_all_samps$tip.label)
width <- 0.1
angle <- 30
font_sz <- 2

# Remove years from lineage data
lin_data_no_year <- lin_data
row.names(lin_data_no_year) <- unlist(lapply(strsplit(row.names(lin_data_no_year), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from DR data 
row.names(dr_status_data) <- unlist(lapply(strsplit(row.names(dr_status_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Remove years from location data
row.names(loc_data) <- unlist(lapply(strsplit(row.names(loc_data), "_"), function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

# Transmission wrangling
row.names(trans_non_trans_df) <- trans_non_trans_df$id
trans_non_trans_df <- drop_cols(trans_non_trans_df, "id")
trans_non_trans_df$trans_status <- as.factor(trans_non_trans_df$trans_status)
names(trans_non_trans_df) <- "Transmission"

# Do tree

ggtree_all_samps <- ggtree(tree_all_samps, size = line_sz, layout="fan", open.angle = 10)

# Add lin data
lin_hm <- gheatmap(ggtree_all_samps, lin_data_no_year,
         width = width,
         # offset = offset,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle, 
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  labs(fill = "Lineage")+
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) ) +
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = width * 0.025,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = font_sz) +
  labs(fill = "DR status")+
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  legend_spec

# dr_status_hm

dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

dr_status_loc_hm <- gheatmap(dr_status_hm, loc_data,
                   width = width,
                   offset = width * (0.025*2),
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = font_sz) +
  labs(fill = "Location")+
  scale_fill_manual(values = loc_cols, breaks = names(loc_cols), na.value="white")+
  legend_spec

# Transmission

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
dr_status_loc_hm <- dr_status_loc_hm + ggnewscale::new_scale_fill()

gheatmap(dr_status_loc_hm, trans_non_trans_df,
         width = width,
         offset = width * (0.025*3),
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "Transmission status") +
  labs(fill = "Transmission status")+
  scale_fill_manual(values=c("white", "black"), labels = c("Transmission", "Non-transmission"))+
  legend_spec



```

***

```{r dr-trees-noref, echo=FALSE, out.width = "1500px", fig.height=8, dpi = 300, warning = F, message = F, cache=F, fig.show="hold"}


# -------------
# Add DR stuff 
# -------------

# Tree setup
width <- 0.02
n_samps <- length(tree_all_samps$tip.label)
y_lim <- c(-10, n_samps + (n_samps * 0.1))
font_sz <- 2
width <- 0.1
angle <- 45
line_sz <- 0.2

# Draw basic tree
gg_dr_tree <- ggtree(tree_all_samps, size = line_sz) +
  coord_cartesian(ylim = y_lim) 
  # scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim) +
  # theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))

lin_hm <- gheatmap(gg_dr_tree, lin_data_no_year,
         width = width,
         # offset = offset,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle, 
         colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) ) +
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = width * 0.025,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours)) +
  labs(fill = "DR status")+
  legend_spec

# dr_status_hm

dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

lin_dr_loc_hm <- gheatmap(dr_status_hm, loc_data,
                   width = width,
                   offset = width * (0.025*2),
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = loc_cols, breaks = names(loc_cols), na.value="white")+
  labs(fill = "Location")+
  legend_spec

lin_dr_loc_hm <- lin_dr_loc_hm + ggnewscale::new_scale_fill()


# Drug resistance - DST

# Strip date
row.names(dr_data) <- unlist(lapply(strsplit(row.names(dr_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))
# pdf(file = dr_trees_pdf_file)
gheatmap(lin_dr_loc_hm, dr_data,
         offset = width * (0.025*3.5),
         width = width+2,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec




# Drug resistance from TB profiler (genotypic drug resistance predictions)
# Strip dates from dr_tbp_data
row.names(dr_tbp_data) <- unlist(lapply(strsplit(row.names(dr_tbp_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))
gheatmap(lin_dr_loc_hm, dr_tbp_data,
         offset = width * (0.025*3.5),
         width = width+2,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec


# Drug discrepancy
# Strip date

row.names(drug_discrepancy_data) <- unlist(lapply(strsplit(row.names(drug_discrepancy_data), "_"),
                                        function(x){ paste0(x[1:(length(x)-1)], collapse = "_") }))

```

```{r dr-trees, echo=FALSE, out.width = "1500px", fig.height=8, dpi = 300, warning = F, message = F, cache=F, fig.show="hold", fig.cap="Phyolgenetic trees of all samples and A: DST drug resistance; B: genotypic drug resistance; C: Discrepancies between DST and genotypic resistance."}

gheatmap(lin_dr_loc_hm, drug_discrepancy_data,
         offset = width * (0.025*3.5),
         width = width+2,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec


```

***

```{r map, echo=FALSE, fig.width=6, fig.height=7, cache=F, dpi=300, message = F, warning = F, fig.cap=sprintf("Locations of samples; n = %s", length(obj$tree$tip.label))}

phylo_plot_file <- "../plots/phylomap.png"

# png(phylo_plot_file, width = 1000, height = 1000, res = 150)
# plot(obj, lty = 1, fsize = 0.01, direction = "rightwards", colors = map_cols, pch=20, lwd = 1)
# legend("bottomright", legend = regions_uniq, fill = regions_cols, cex = 0.75)
# dev.off()

include_graphics(phylo_plot_file)

# fig.width=6, fig.height=6

```


***

<!--
```{r dates, echo=FALSE, out.width = "2000px", fig.cap=sprintf("Histogram of sample collection year; n = %s", n_dated_samps)}

# year <- round(as.numeric(metadata$year[!is.na(metadata$year)], 1))
# years <- sort(unique(year))
# breaks <- (min(year)-0.5):(max(year)+0.5)
# yr_hist <- hist(year, freq = T, xaxt="n", xlab= "year",
#                 breaks = breaks, col = col, main = "")
# axis(side = 1, at = yr_hist$mids, labels = years)

```
-->

***

<!--
```{r boxdistance, echo=FALSE, fig.show="hold", out.width="50%", fig.cap = sprintf("Boxplot of pairwise SNP distances (excluding DR sites), all samples (left; n = %s), samples within %s SNP distance (right; n = %s).", nrow(dist), threshold, nrow(as.matrix(dist_thresh)))}

# Summary of distances for all samples
# lower_dist <- dist[lower.tri(dist)]
boxplot(lower_dist, 
    col = col, 
    main = sprintf("mean = %s; median = %s", round(mean(lower_dist), rnd), round(median(lower_dist), rnd) ), 
    cex.main = main_cex, 
    ylab="SNP distance")

# Summary of dists for threshold (clustered) samples
# dist_dated <- dist[dated_samps, dated_samps]
# lower_dist_dated <- dist_dated[lower.tri(dist_dated)]
boxplot(dist_thresh, col = col,
        main = sprintf("mean = %s; median = %s", round(mean(dist_thresh), rnd), round(median(dist_thresh), rnd) ),
        cex.main = main_cex,
        ylab="SNP distance")

```
-->

```{r dist-dens-all-samples, echo=FALSE, fig.show="hold", out.width="50%", dpi=300, fig.cap = sprintf("Density of pairwise SNP distances for all samples (n=%s)", n_samps_total)}

dist_dens_all_samples

```


<!--
```{r clusterstree, echo = F, out.width = "2000px", fig.cap = sprintf("Single linkage tree of SNP distances, dated samples. Line shown at a SNP distance of %s; n = %s; n clusters = %s", threshold, nrow(dist), n_clusters_cut_tree)}

# # dist_dated <- as.dist(dist_dated)
# 
# # Convert to 'distance matrix' (extract lower triangle)
# dist_dated[upper.tri(dist_dated, diag = T)] <- 0
# 
# # Cluster using 'single' method.
# # Clusters all samples within distance of threshold
# clust <- hclust(as.dist(dist_dated), method = "single")
plot(clust, labels = F, xlab = "", main = "")
abline(a = threshold, b = 0)
# # Cut tree at threshold to find samples within threshold
# clusters <- sort(cutree(clust, h = threshold))
# 
# # Filter for clusters (take out the samples with their own number, i.e., those not in a group)
# # Gets samples below the threshold
# clusters <- clusters[clusters %in% names(which(table(clusters) > 1)) ]
# 
# n_clusters_cut_tree <- length(unique(clusters))
# 
# # Subset
# dist_dated_thresh <- as.dist(dist_dated[sort(names(clusters)), sort(names(clusters))])
# dist_dated_thresh <- dist_dated_thresh+1 # Add 1 because 1/x later.

```
-->

***

```{r distanceqgraph-noref, echo=FALSE, out.width = "2000px", fig.height=3, dpi = 300, fig.show="hold"}


# qgraph::qgraph(1/dist_dated_thresh, layout='spring', vsize=5)

# Subset
# lin_data_qgraph <- lin_data[row.names(lin_data) %in% attributes(dist_dated_thresh)$Labels, "Lineage", drop = F]
lin_data_qgraph <- lin_data_no_year[row.names(lin_data_no_year) %in% attributes(dist_thresh)$Labels, "Lineage", drop = F]
# Add sample names to df
lin_data_qgraph$samp <- row.names(lin_data_qgraph)
# Convert to DM for easy access to row and col names
# dist_mat <- as.matrix(dist_dated_thresh)
dist_mat <- as.matrix(dist_thresh)
# Get the row index for each samp in the DM
dist_samp_ind <- data.frame(samp = row.names(dist_mat), row = seq(row.names(dist_mat)))
# Merge with lin data
lin_data_qgraph <- merge(dist_samp_ind, lin_data_qgraph,
                         by = "samp", 
                         sort = F)
# Split by lin
lin_data_split <- split(lin_data_qgraph, lin_data_qgraph$Lineage)
# Loop over split df and replace lists with row nums
for(i in seq(lin_data_split)){
  lin_data_split[[i]] <- lin_data_split[[i]]$row
}

# Edge thickness
cut_val <- 0.5
# Node size
vsize_val <- 2
leg_cex <- 0.4

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = lin_data_split, 
               legend = TRUE, 
               color = lin_colours, 
               labels = F, 
               legend.cex = leg_cex)


# Same for DR data
dr_status_data_qgraph <- dr_status_data[row.names(dr_status_data) %in% attributes(dist_thresh)$Labels, "DR status", drop = F]
dr_status_data_qgraph$samp <- row.names(dr_status_data_qgraph)
dr_data_qgraph <- merge(dist_samp_ind, dr_status_data_qgraph,
                         by = "samp", 
                         sort = F)
dr_data_split <- split(dr_data_qgraph, dr_data_qgraph["DR status"])
# Re-arrange order to match col vector
dr_data_split <- dr_data_split[names(dr_status_colours)]

for(i in seq(dr_data_split)){
  dr_data_split[[i]] <- dr_data_split[[i]]$row
}

qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = dr_data_split, 
               legend = TRUE, 
               color = dr_status_colours, 
               labels = F, 
               legend.cex = leg_cex)

# Location
loc_data_qgraph <- loc_data[row.names(loc_data) %in% attributes(dist_thresh)$Labels, "Location", drop = F]
loc_data_qgraph$samp <- row.names(loc_data_qgraph)
loc_data_qgraph <- merge(dist_samp_ind, loc_data_qgraph,
                         by = "samp", 
                         sort = F)
# Convert NA to something else
loc_data_qgraph[is.na(loc_data_qgraph$Location), "Location"] <- "N/A"
# Do the same for col
names(loc_cols)[is.na(names(loc_cols))] <- "N/A"
loc_data_split <- split(loc_data_qgraph, loc_data_qgraph["Location"], drop = T)

# Subset so that next line does not contain NAs (does for some reason if don't match)
loc_cols_qgraph <- loc_cols[names(loc_cols) %in% names(loc_data_split)]
# Re-order split-df to same order as loc vector
loc_data_split <- loc_data_split[names(loc_cols_qgraph)]

for(i in seq(loc_data_split)){
  loc_data_split[[i]] <- loc_data_split[[i]]$row
}


```

```{r distanceqgraph, echo=FALSE, out.width = "2000px", fig.height=3, dpi = 300, fig.cap = sprintf("Connections among samples with <= %s SNP distance; n = %s. Thicker lines indicate smaller SNP distance.", threshold, length(attributes(dist_thresh)$Labels)), fig.show="hold"}


qgraph::qgraph(1/dist_thresh, 
               layout='spring',
               minimum = 1/threshold,
               vsize=vsize_val,
               cut = cut_val,
               borders = T, 
               groups = loc_data_split, 
               legend = TRUE, 
               color = loc_cols_qgraph, 
               labels = F, 
               legend.cex = leg_cex)

  
```

***

```{r trans-category-plots-noref, echo=FALSE, out.width = "2000px", dpi = 300, fig.height=5, fig.width=7, fig.show="hold"}

# Lin

# par(mfrow = c(1, 1))
balloonplot(t(lin_contingency_tab), 
            main = sprintf("Samples within %s-SNP threshold, by lineage", threshold), 
            xlab ="", ylab="",
            label = T, show.margins = FALSE)
corrplot(trans_lin_chi_sq$residuals, is.cor = FALSE)

# DR

balloonplot(t(dr_contingency_tab), 
            main = sprintf("Samples within %s-SNP threshold, by DR status", threshold), 
            xlab ="", ylab="",
            label = T, show.margins = FALSE, colsrt = 90)
corrplot(trans_dr_chi_sq$residuals, is.cor = FALSE)

# Loc

balloonplot(t(loc_contingency_tab), 
            main = sprintf("Samples within %s-SNP threshold, by location", threshold), 
            xlab ="", ylab="",
            label = T, show.margins = FALSE, show.zeros = T, colsrt = 90, text.size = 0.75, label.size = 0.75)


```

```{r trans-category-plots, echo=FALSE, out.width = "2000px", dpi = 300, fig.height=5, fig.width=7, fig.cap = sprintf("Proportions of samples within %s SNPs (top) and size of residuals in chi-square tests (bottom) for lineage, drug resistance status and location.", threshold), fig.show="hold"}

corrplot(trans_loc_chi_sq$residuals, is.cor = FALSE, mar = c(0, 0, 0, 0), cl.cex = 0.5)

```

***

```{r asr-tree, echo=FALSE, out.width = "2000px", dpi = 300, fig.cap = sprintf("Tree with the Pakistan samples and closely-related global isolates from previously published datasets. The posterior probability for the ancestral state reconstruction of subregion of sample collection is indicated by the pie charts on the internal nodes. (n = 915)")}

include_graphics(asr_file)

```

***

```{r n-clusters-plot-noref, echo = F, out.width = "2000px", dpi = 300, fig.show="hold"}

plot(threshold_vect, n_clusts_vect, type = 'l', xaxt = "n", xlab = "SNP distance threshold", ylab = "n clusters")
axis(1, at = threshold_vect, las = 2)

```

```{r n-clusters-plot, echo = F, out.width = "2000px", dpi = 300, fig.show="hold", fig.cap="Number of clusters and number of samples by SNP distance threshold in clustering sensitivity analysis"}

plot(threshold_vect, n_samps_per_cluster_vect, type = 'l', xaxt = "n", xlab = "SNP distance threshold", ylab = "n clustering samples")
axis(1, at = threshold_vect, las = 2)

```

***

<!--
```{r beasttrees, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap="Timed phylogenetic trees of all dated samples (n = n_dated_samps), inferred from BEAST. A - Timed phylogenetic tree annotated with drug resistance statuses from phylogenetic tests (DST); B - The same tree annotated with drug resistance statuses from genotypic profiling (TBprofiler); C - Annotated with the discrepancies between the phenotypic and genotypic tests."}


# Get first date from tree (i.e. date of the root)
# first_date <- mcc_tree_ape$root.edge
first_date <- log_table[grep("mrca.date", row.names(log_table))]
first_date <- plyr::round_any(first_date, 10)


first_date <- 0

# Get last date from the samples
last_date <- as.numeric(max(unlist(lapply(strsplit(mcc_tree_ape$tip.label, "_"), function(x){x[length(x)]}))))
last_date_chr <- paste0(as.character(ceiling(last_date)), "-12-31")
n_samps <- length(mcc_tree_ape$tip.label)

# Tree setup
x_lim <- c(first_date-10, last_date+(last_date*0.8))
y_lim <- c(-5, n_samps + (n_samps * 0.1))
v_line_col <- "red"
x_labs_full <- seq(first_date, last_date, by = 100)
x_labs_zoom <- seq(last_date-50, last_date, by = 1)
offset <- 50
width <- 0.05
angle <- 45
line_sz <- 0.2




# x <- mcc_tree
# x <- as.phylo(x)
# x <- phyclust::rescale.rooted.tree(x, scale.height = 1)
# ggtree(x, mrsd = last_date_chr, size = line_sz) +
#   theme_tree2() +
#   scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)





# Draw basic tree
gg_mcmc_tree <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) +
  theme_tree2() +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  # geom_range("length_0.95_HPD", color='red', size=2, alpha=.5) +
  # geom_text2(aes(label=round(as.numeric(posterior), 2),
  #                subset=as.numeric(posterior)> 0.9,
  #                x=branch), vjust=0) +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim) +
  theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree, lin_data,
         width = width,
         offset = offset, color = NULL,
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                   width = width,
                   offset = offset+100, color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR status")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()

width_plus <- 0.6
font_sz <- 2

# pdf(file = dr_trees_pdf_file)
gheatmap(dr_status_hm, dr_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

# Drug resistance from TB profiler (genotypic drug resistance predictions)

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset+200,
         width = width + width_plus,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset+200,
         width = width + width_plus,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

```
-->


<!--
```{r beasttreeszoom, echo=FALSE, out.width = "1500px", warning = F, message = F, cache=F, fig.show="hold", fig.cap=sprintf("The same trees and annotations as Figure \\@ref(fig:beasttrees), zoomed in to the last 50 years before the last sample date. Samples which do not form a cluster (the MRCA was before 50 years or there is only one sample) have been dropped. n = %s",  n_beast_cluster_samps)}

# Zoom in to clusters

# Zoom tree setup
zoom_range <- c((last_date+1) - 50, (last_date + 1) + 65)
zoom_range_seq <- seq(zoom_range[1], (last_date+1), 2)

offset_zoom <- 0
width_zoom <- 0.0015

gg_mcmc_tree_zoom <- ggtree(mcc_tree, mrsd = last_date_chr, size = line_sz) %<+% metadata +
  # geom_tiplab(align=TRUE, linetype='dashed', linesize=.3, size = 2) +
  geom_tiplab(align=T, size = 1.5, linetype=NA, hjust = -3.9)+
  theme_tree2() +
  coord_cartesian(ylim = y_lim) +
  scale_x_continuous(breaks = zoom_range_seq,
                    labels = zoom_range_seq,
                    limits = zoom_range) +
  # scale_x_continuous(breaks = x_labs_full, labels = x_labs_full, limits = x_lim)+
  geom_vline(aes(xintercept = 2020), col = "red")+
  # geom_tiplab(align = TRUE, linetype='dashed', linesize=.3, size = 2) +
  theme(axis.text.x = element_text(face = "bold", size = 6, angle = 45, hjust = 1))

# Add lin data
lin_hm <- gheatmap(gg_mcmc_tree_zoom, lin_data,
                   width = width_zoom,
                   offset = offset_zoom,
                   color = NULL,
                   colnames_position = "top",
                   colnames_angle = angle, colnames_offset_y = 1,
                   hjust = 0,
                   font.size = 2) +
  scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
  labs(fill = "Lineage")+
  legend_spec

# Do this to add new gheatmap for some reason
# See "7.3.1 Visualize tree with multiple associated matrix" https://yulab-smu.top/treedata-book/chapter7.html
lin_hm <- lin_hm + ggnewscale::new_scale_fill()

# Add DR status
dr_status_hm <- gheatmap(lin_hm, dr_status_data,
                         width = width_zoom,
                         offset = offset_zoom + 2.5,
                         color = NULL,
                         colnames_position = "top",
                         colnames_angle = angle, colnames_offset_y = 1,
                         hjust = 0,
                         font.size = 2) +
  scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
  labs(fill = "DR\nstatus")+
  legend_spec

# Add DR individual status
dr_status_hm <- dr_status_hm + ggnewscale::new_scale_fill()
offset_zoom_plus <- 6

gheatmap(dr_status_hm, dr_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance")+
  legend_spec

gheatmap(dr_status_hm, dr_tbp_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         # color = NULL,
         low="white", high="black", color="black",
         colnames_position = "top",
         colnames_angle = angle, colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz,
         legend_title = "llw") +
  scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
  labs(fill = "Drug\nresistance\n(TB profiler)")+
  legend_spec

# Drug resistance genotype/phenotype discrepancies taking off from dr_status_hm tree

gheatmap(dr_status_hm, drug_discrepancy_data,
         offset = offset_zoom + offset_zoom_plus,
         width = width_zoom + 0.02,
         color = NULL,
         colnames_position = "top",
         colnames_angle = angle,
         colnames_offset_y = 1,
         hjust = 0,
         font.size = font_sz) +
  scale_fill_manual(values = drug_discrepancy_cols, breaks = names(drug_discrepancy_cols))+
  labs(fill = "Phen./Gen diff")+
  legend_spec

# dev.off()

# # Loop through clusters
# 
# clusters_split <- split(beast_clusters, beast_clusters$cluster)
# mcc_tree_tips <- mcc_tree@phylo$tip.label
# 
# # pdf(file = beast_clusters_pdf_file)
# for(i in seq(clusters_split)){
# 
#   names_to_keep <- clusters_split[[i]]$id
#   names_to_drop <- mcc_tree_tips[!(mcc_tree_tips %in% names_to_keep)]
#   clust_tree <- treeio::drop.tip(mcc_tree, names_to_drop)
# 
#   # Do tree first to get first and last date
#   last_date_clust <- as.numeric(max(unlist(lapply(strsplit(clust_tree@phylo$tip.label, "_"), function(x){x[length(x)]}))))
#   last_date_clust_chr <- paste0(as.character(last_date), "-12-31")
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2()
#   last_date_clust <- ceiling(max(gg_clust_tree$data$x))
#   first_date_clust <- floor(min(gg_clust_tree$data$x))
# 
#   n_samps <- length(clust_tree@phylo$tip.label)
#   last_date_clust_chr <- paste0(last_date_clust-1, "-12-31")
#   date_range_clust <- c(first_date_clust, last_date_clust)
#   year_span_clust <- diff(date_range_clust)
#   oom <- log10_ceiling(year_span_clust)
#   if(oom == 1){
#     by <- 1
#   }else if(oom == 10){
#     by <- 2
#   }else if(oom == 100){
#     by <- 10
#   }else{
#     by <- 100
#   }
#   zoom_range_seq_clust <- seq(first_date_clust,
#                               last_date_clust,
#                               by = by)
# 
#   post_tree_multiply <- 5
#   post_tree_span <- (year_span_clust * post_tree_multiply)
#   x_lim_clust <- c(first_date_clust - (year_span_clust*0.2), last_date_clust + post_tree_span)
#   y_lim_clust <- c(0 - floor(n_samps*0.1),  n_samps + ceiling(n_samps*0.2) )
#   # width <- width * (p$data$x %>% range(na.rm = TRUE) %>% diff)/ncol(data)
#   width_clust <- 0.035 * post_tree_multiply  # % of tree time span
#   # offset_clust <- (width_clust * year_span_clust) + ((width_clust * year_span_clust)*0.1)
#   offset_clust <- (width_clust * year_span_clust)
# 
#   gg_clust_tree <- ggtree(clust_tree, mrsd = last_date_clust_chr) %<+% metadata +
#     theme_tree2() +
#     coord_cartesian(ylim = y_lim_clust) +
#     scale_x_continuous(breaks = zoom_range_seq_clust,
#                        labels = zoom_range_seq_clust,
#                        limits = x_lim_clust) +
#     geom_vline(aes(xintercept = last_date_clust), col = "red")+
#     theme(axis.text.x = element_text(face = "bold", size = 8, angle = 45, hjust = 1))
# 
# # Add lin data
# lin_hm_clust <- gheatmap(gg_clust_tree, lin_data,
#                    width = width_clust,
#                    offset = 0,
#                    color = NULL,
#                    colnames_position = "top",
#                    colnames_angle = angle,
#                    # colnames_offset_y = 1,
#                    hjust = 0,
#                    font.size = 3) +
#   scale_fill_manual(values = lin_colours, breaks = names(lin_colours) )+
#   labs(fill = "Lineage")
# 
# lin_hm_clust <- lin_hm_clust + ggnewscale::new_scale_fill()
# 
# # Add DR status clusters
# dr_status_hm_clust <- gheatmap(lin_hm_clust, dr_status_data,
#                          width = width_clust,
#                          offset = offset_clust,
#                          color = NULL,
#                          colnames_position = "top",
#                          colnames_angle = angle,
#                          # colnames_offset_y = 1,
#                          hjust = 0,
#                          font.size = 3) +
#   scale_fill_manual(values = dr_status_colours, breaks = names(dr_status_colours) )+
#   labs(fill = "DR\nstatus")
# 
# dr_status_hm_clust <- dr_status_hm_clust + ggnewscale::new_scale_fill()
# 
# final_plot <- gheatmap(dr_status_hm_clust, dr_data,
#          width = width_clust * ncol(dr_data),
#          # offset = ceiling(offset_clust * 3),
#          offset = (offset_clust * 2) + (offset_clust * 0.2),
#          # color = NULL,
#          low="white", high="black", color="black",
#          colnames_position = "top",
#          colnames_angle = angle,
#          colnames_offset_y = 0,
#          hjust = 0,
#          font.size = 2.5,
#          legend_title = "llw") +
#   scale_fill_manual(values=c("white", "black"), labels = c("Sensitive", "Resistant", "NA"), na.value = "grey")+
#   labs(fill = "Drug\nresistance")
# 
# print(final_plot)
# }
# # dev.off()


```
-->


<!--
```{r beastlogplots, echo=FALSE, out.width = "1500px", fig.cap = "Trace plots of BEAST MCMC iterations across posterior, likelihood, prior and MRCA parameters. The plots show no upward or downward trend, hence imply convergence."}

par(mfrow = c(2, 2))

plot(beast_log$posterior, main = "posterior", type= 'l', ylab = "posterior")
plot(beast_log$likelihood, main = "likelihood", type= 'l', ylab = "likelihood")
plot(beast_log$prior, main = "prior", type= 'l', ylab = "prior")
plot(beast_log$mrca.date.forward.TreePrior., main = "MRCA", type= 'l', ylab = "MRCA")

par(mfrow=c(1,1))

```
-->

### References













